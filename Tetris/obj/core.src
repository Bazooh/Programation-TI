; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\CORE.C"
	.assume ADL=1
	SEGMENT DATA
_TIMER:
	DW	16384
	DW	6553
	DW	4096
;    1	
;    2	#include "core.h"
;    3	
;    4	uint16_t TIMER[3] = {32768/2, 32768/5, 32768/8};
	SEGMENT CODE
;    5	
;    6	t_piece *createPiece() {
_createPiece:
	LD	HL,-3
	CALL	__frameset
;    7	    uint32_t random_number;
;    8	    t_piece *new_piece;
;    9	
;   10	    if (!(new_piece = malloc(sizeof(t_piece))))
	LD	BC,36
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-3),HL
	CALL	__icmpzero
	JR	NZ,L_8
	OR	A,A
;   11	        return NULL;
	SBC	HL,HL
	JR	L_10
L_8:
;   12	
;   13	    switch (randInt(0, 6)) {
	CALL	_random
	LD	BC,7
	CALL	__iremu
	CALL	__seqcase
L__1:
	DW	7
	DW	0
	DB	0
	DW24	L_1	

	DW24	L_2	

	DW24	L_3	

	DW24	L_4	

	DW24	L_5	

	DW24	L_6	

	DW24	L_7	

	DW24	L_9	

;   14	        case 0 :
L_1:
;   15	            *new_piece = PIECE_0;
	LD	DE,(IX+-3)
	LD	HL,_PIECE_0
	LD	BC,36
	LDIR	
;   16	            break;
	JR	L_9
;   17	        case 1 :
L_2:
;   18	            *new_piece = PIECE_1;
	LD	DE,(IX+-3)
	LD	HL,_PIECE_1
	LD	BC,36
	LDIR	
;   19	            break;
	JR	L_9
;   20	        case 2 :
L_3:
;   21	            *new_piece = PIECE_2;
	LD	DE,(IX+-3)
	LD	HL,_PIECE_2
	LD	BC,36
	LDIR	
;   22	            break;
	JR	L_9
;   23	        case 3 :
L_4:
;   24	            *new_piece = PIECE_3;
	LD	DE,(IX+-3)
	LD	HL,_PIECE_3
	LD	BC,36
	LDIR	
;   25	            break;
	JR	L_9
;   26	        case 4 :
L_5:
;   27	            *new_piece = PIECE_4;
	LD	DE,(IX+-3)
	LD	HL,_PIECE_4
	LD	BC,36
	LDIR	
;   28	            break;
	JR	L_9
;   29	        case 5 :
L_6:
;   30	            *new_piece = PIECE_5;
	LD	DE,(IX+-3)
	LD	HL,_PIECE_5
	LD	BC,36
	LDIR	
;   31	            break;
	JR	L_9
;   32	        case 6 :
L_7:
;   33	            *new_piece = PIECE_6;
	LD	DE,(IX+-3)
	LD	HL,_PIECE_6
	LD	BC,36
	LDIR	
;   34	            break;
;   35	    }
L_9:
;   36	    return new_piece;
	LD	HL,(IX+-3)
;   37	}
L_10:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _createPiece ***************************
;Name                         Addr/Register   Size   Type
;_PIECE_6                            IMPORT     36   variable
;_PIECE_5                            IMPORT     36   variable
;_PIECE_4                            IMPORT     36   variable
;_PIECE_3                            IMPORT     36   variable
;_PIECE_2                            IMPORT     36   variable
;_PIECE_1                            IMPORT     36   variable
;_PIECE_0                            IMPORT     36   variable
;_random                             IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;new_piece                             IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;   38	
;   39	uint8_t checkCaseMovement(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_pos checking_case) {
_checkCaseMovement:
	CALL	__frameset0
;   40	    if (checking_case.x < 0 || checking_case.x >= MATRIX_X_LENGTH) {
	LD	A,(IX+9)
	OR	A,A
	JP	M,L_12
	LD	A,(IX+9)
	CP	A,10
	CALL	__setflag
	JP	M,L_14
L_12:
;   41	        return 0;
	XOR	A,A
	JR	L_19
;   42	    }
L_14:
;   43	    if (checking_case.y >= MATRIX_Y_LENGTH) {
	LD	A,(IX+10)
	CP	A,20
	CALL	__setflag
	JP	M,L_17
;   44	        return 0;
	XOR	A,A
	JR	L_19
;   45	    }
L_17:
;   46	    if (checking_case.y >= 0) {
	LD	A,(IX+10)
	OR	A,A
	JP	M,L_18
;   47	        if (matrix[checking_case.y][checking_case.x] != WHITE) {
	LD	A,(IX+10)
	SEXT	HL
	LD	L,(IX+10)
	LD	A,10
	CALL	__imul_b
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IX+9)
	SEXT	HL
	LD	L,(IX+9)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	Z,L_18
;   48	            return 0;
	XOR	A,A
	JR	L_19
;   49	        }
;   50	    }
L_18:
;   51	    return 1;
	LD	A,1
;   52	}
L_19:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkCaseMovement ***************************
;Name                         Addr/Register   Size   Type
;checking_case                         IX+9      2   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;   53	
;   54	uint8_t checkPieceMovement(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece piece) {
_checkPieceMovement:
	LD	HL,-15
	CALL	__frameset
;   55	    uint8_t i;
;   56	    t_pos piece_pos;
;   57	
;   58	    for (i = 0 ; i < SIZE_OF_PIECE ; i++) {
	LD	(IX+-1),0
	JR	L_24
L_22:
;   59	        piece_pos.x = piece.pos.x + piece.rotation_pos[piece.rotation_state][i].x;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	(IX+-6),BC	; spill
	LD	(IX+-12),HL	; spill
	LD	BC,(IX+-6)	; unspill
;   60	        piece_pos.y = piece.pos.y + piece.rotation_pos[piece.rotation_state][i].y;
	LD	(IX+-6),BC	; spill
	LD	(IX+-9),HL	; spill
	LD	BC,(IX+-6)	; unspill
	LD	A,(IX+44)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LEA	DE,IX+9
	ADD	HL,DE
	LD	(IX+-6),BC	; spill
	LD	BC,(IX+-12)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-6)	; unspill
	LD	IY,HL
	LD	A,(IY+0)
	ADD	A,(IX+41)
	LD	(IX+-3),A
	LD	A,(IX+44)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LEA	DE,IX+9
	ADD	HL,DE
	LD	(IX+-6),BC	; spill
	LD	BC,(IX+-9)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-6)	; unspill
	LD	IY,HL
	LD	A,(IY+1)
	ADD	A,(IX+42)
	LD	(IX+-2),A
;   61	        if (!(checkCaseMovement(matrix, piece_pos))) {
	PUSH	BC
	LEA	HL,IX+-3
	LD	BC,2
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LDIR	
	LD	DE,(IX+6)
	PUSH	DE
	LD	(IX+-15),BC
	CALL	_checkCaseMovement
	LD	BC,(IX+-15)
	POP	DE
	POP	DE
	OR	A,A
	JR	NZ,L_23
;   62	            return 0;
	XOR	A,A
	JR	L_26
;   63	        }
;   64	    }
L_23:
	INC	(IX+-1)
L_24:
	LD	A,(IX+-1)
	CP	A,4
	JR	C,L_22
;   65	    return 1;
	LD	A,1
;   66	}
L_26:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkPieceMovement ***************************
;Name                         Addr/Register   Size   Type
;_checkCaseMovement                  IMPORT  -----   function
;piece_pos                             IX-3      2   variable
;i                                     IX-1      1   variable
;piece                                 IX+9     36   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 60 (bytes)
;       Spill Code: 0 (instruction)


;   67	
;   68	void initMatrix(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH]) {
_initMatrix:
	LD	HL,-2
	CALL	__frameset
;   69	    uint8_t i;
;   70	    uint8_t j;
;   71	
;   72	    for (i = 0; i < MATRIX_Y_LENGTH; i++) {
	LD	(IX+-1),0
	JR	L_34
L_32:
;   73	        for (j = 0; j < MATRIX_X_LENGTH; j++) {
	LD	(IX+-2),0
	JR	L_31
L_29:
;   74	            matrix[i][j] = WHITE;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LD	A,(IX+-2)
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(HL),1
	INC	(IX+-2)
;   75	        }
L_31:
	LD	A,(IX+-2)
	CP	A,10
	JR	C,L_29
	INC	(IX+-1)
;   76	    }
L_34:
	LD	A,(IX+-1)
	CP	A,20
	JR	C,L_32
;   77	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _initMatrix ***************************
;Name                         Addr/Register   Size   Type
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;matrix                                IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


;   78	
;   79	void moveLeft(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece) {
_moveLeft:
	LD	HL,-39
	CALL	__frameset
;   80	    uint8_t i;
;   81	    t_piece checking_piece;
;   82	    checking_piece = *piece;
	LEA	DE,IX+-39
	LD	HL,(IX+9)
	LD	BC,36
	LDIR	
;   83	
;   84	    checking_piece.pos.x--;
	LEA	BC,IX+-7
	LD	(IX+-3),BC
	LD	IY,(IX+-3)
	LD	A,(IY+0)
	DEC	A
	LD	(IY+0),A
;   85	
;   86	    if (checkPieceMovement(matrix, checking_piece)) {
	LD	IY,0
	ADD	IY,SP
	OR	A,A
	SBC	HL,HL
	LEA	IY,IY+-36
	LD	SP,IY
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-39
	LD	BC,36
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkPieceMovement
	LD	IY,39
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_38
;   87	        clearPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_clearPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;   88	        *piece = checking_piece;
	LD	DE,(IX+9)
	LEA	HL,IX+-39
	LD	BC,36
	LDIR	
;   89	        printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;   90	    }
;   91	}
L_38:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _moveLeft ***************************
;Name                         Addr/Register   Size   Type
;_printPiece                         IMPORT  -----   function
;_clearPiece                         IMPORT  -----   function
;_checkPieceMovement                 IMPORT  -----   function
;checking_piece                       IX-39     36   variable
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 51 (bytes)
;       Spill Code: 0 (instruction)


;   92	
;   93	void moveRight(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece) {
_moveRight:
	LD	HL,-39
	CALL	__frameset
;   94	    uint8_t i;
;   95	    t_piece checking_piece;
;   96	    checking_piece = *piece;
	LEA	DE,IX+-39
	LD	HL,(IX+9)
	LD	BC,36
	LDIR	
;   97	
;   98	    checking_piece.pos.x++;
	LEA	BC,IX+-7
	LD	(IX+-3),BC
	LD	IY,(IX+-3)
	LD	A,(IY+0)
	INC	A
	LD	(IY+0),A
;   99	
;  100	    if (checkPieceMovement(matrix, checking_piece)) {
	LD	IY,0
	ADD	IY,SP
	OR	A,A
	SBC	HL,HL
	LEA	IY,IY+-36
	LD	SP,IY
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-39
	LD	BC,36
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkPieceMovement
	LD	IY,39
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_41
;  101	        clearPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_clearPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  102	        *piece = checking_piece;
	LD	DE,(IX+9)
	LEA	HL,IX+-39
	LD	BC,36
	LDIR	
;  103	        printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  104	    }
;  105	}
L_41:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _moveRight ***************************
;Name                         Addr/Register   Size   Type
;_printPiece                         IMPORT  -----   function
;_clearPiece                         IMPORT  -----   function
;_checkPieceMovement                 IMPORT  -----   function
;checking_piece                       IX-39     36   variable
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 51 (bytes)
;       Spill Code: 0 (instruction)


;  106	
;  107	void leftRotation(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece) {
_leftRotation:
	LD	HL,-36
	CALL	__frameset
;  108	    t_piece checking_piece;
;  109	
;  110	    checking_piece = *piece;
	LEA	DE,IX+-36
	LD	HL,(IX+9)
	LD	BC,36
	LDIR	
;  111	
;  112	    if (checking_piece.rotation_state > 0) {
	XOR	A,A
	CP	A,(IX+-1)
	JR	NC,L_44
;  113	        checking_piece.rotation_state-- ;
	DEC	(IX+-1)
;  114	    }
;  115	    else {
	JR	L_46
L_44:
;  116	        checking_piece.rotation_state = NUMBER_OF_ROTATION - 1;
	LD	(IX+-1),3
;  117	    }
L_46:
;  118	
;  119	    if (checkPieceMovement(matrix, checking_piece)) {
	LD	IY,0
	ADD	IY,SP
	OR	A,A
	SBC	HL,HL
	LEA	IY,IY+-36
	LD	SP,IY
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-36
	LD	BC,36
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkPieceMovement
	LD	IY,39
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_47
;  120	        clearPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_clearPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  121	        *piece = checking_piece;
	LD	DE,(IX+9)
	LEA	HL,IX+-36
	LD	BC,36
	LDIR	
;  122	        printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  123	    }
;  124	}
L_47:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _leftRotation ***************************
;Name                         Addr/Register   Size   Type
;_printPiece                         IMPORT  -----   function
;_clearPiece                         IMPORT  -----   function
;_checkPieceMovement                 IMPORT  -----   function
;checking_piece                       IX-36     36   variable
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 48 (bytes)
;       Spill Code: 0 (instruction)


;  125	
;  126	void rightRotation(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece) {
_rightRotation:
	LD	HL,-36
	CALL	__frameset
;  127	    t_piece checking_piece;
;  128	    checking_piece = *piece;
	LEA	DE,IX+-36
	LD	HL,(IX+9)
	LD	BC,36
	LDIR	
;  129	
;  130	    if (checking_piece.rotation_state < NUMBER_OF_ROTATION - 1) {
	LD	A,(IX+-1)
	CP	A,3
	JR	NC,L_50
;  131	        checking_piece.rotation_state++ ;
	INC	(IX+-1)
;  132	    }
;  133	    else {
	JR	L_52
L_50:
;  134	        checking_piece.rotation_state = 0;
	LD	(IX+-1),0
;  135	    }
L_52:
;  136	
;  137	    if (checkPieceMovement(matrix, checking_piece)) {
	LD	IY,0
	ADD	IY,SP
	OR	A,A
	SBC	HL,HL
	LEA	IY,IY+-36
	LD	SP,IY
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-36
	LD	BC,36
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkPieceMovement
	LD	IY,39
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_53
;  138	        clearPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_clearPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  139	        *piece = checking_piece;
	LD	DE,(IX+9)
	LEA	HL,IX+-36
	LD	BC,36
	LDIR	
;  140	        printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  141	    }
;  142	}
L_53:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _rightRotation ***************************
;Name                         Addr/Register   Size   Type
;_printPiece                         IMPORT  -----   function
;_clearPiece                         IMPORT  -----   function
;_checkPieceMovement                 IMPORT  -----   function
;checking_piece                       IX-36     36   variable
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 48 (bytes)
;       Spill Code: 0 (instruction)


;  143	
;  144	void moveDown(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece) {
_moveDown:
	CALL	__frameset0
;  145	    uint8_t i;
;  146	    t_pos piece_pos;
;  147	
;  148	    clearPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_clearPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  149	    piece->pos.y++;
	LD	IY,(IX+9)
	LD	A,(IY+33)
	INC	A
	LD	(IY+33),A
;  150	    printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  151	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _moveDown ***************************
;Name                         Addr/Register   Size   Type
;_printPiece                         IMPORT  -----   function
;_clearPiece                         IMPORT  -----   function
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  152	
;  153	void moveDownMatrix(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], uint8_t y) {
_moveDownMatrix:
	LD	HL,-2
	CALL	__frameset
;  154	    uint8_t i;
;  155	    uint8_t j;
;  156	
;  157	    for (i = y; i > 0; i--) {
	LD	A,(IX+9)
	LD	(IX+-1),A
	JR	L_63
L_61:
;  158	        for (j = 0; j < MATRIX_X_LENGTH; j++) {
	LD	(IX+-2),0
	JR	L_60
L_58:
;  159	            matrix[i][j] = matrix[i - 1][j];
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	DEC	HL
	LD	A,10
	CALL	__imul_b
	LD	A,(IX+-2)
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LD	A,(IX+-2)
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	UEXT	HL
	LD	L,A
	LD	A,(IY)
	ADD	HL,BC
	LD	(HL),A
	INC	(IX+-2)
;  160	        }
L_60:
	LD	A,(IX+-2)
	CP	A,10
	JR	C,L_58
	DEC	(IX+-1)
;  161	    }
L_63:
	XOR	A,A
	CP	A,(IX+-1)
	JR	C,L_61
;  162	    for (i = 0; i < MATRIX_X_LENGTH; i++) {
	LD	(IX+-1),0
	JR	L_67
L_65:
;  163	        matrix[0][i] = WHITE;
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(HL),1
	INC	(IX+-1)
;  164	    }
L_67:
	LD	A,(IX+-1)
	CP	A,10
	JR	C,L_65
;  165	    printScreen(matrix);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_printScreen
	POP	BC
;  166	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _moveDownMatrix ***************************
;Name                         Addr/Register   Size   Type
;_printScreen                        IMPORT  -----   function
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;y                                     IX+9      1   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


;  167	
;  168	uint8_t checkMoveDown(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece) {
_checkMoveDown:
	LD	HL,-39
	CALL	__frameset
;  169	    t_piece checking_piece;
;  170	
;  171	    checking_piece = *piece;
	LEA	DE,IX+-39
	LD	HL,(IX+9)
	LD	BC,36
	LDIR	
;  172	    checking_piece.pos.y++;
	LEA	BC,IX+-7
	LD	(IX+-3),BC
	LD	IY,(IX+-3)
	LD	A,(IY+1)
	INC	A
	LD	(IY+1),A
;  173	
;  174	    if (checkPieceMovement(matrix, checking_piece)) {
	LD	IY,0
	ADD	IY,SP
	OR	A,A
	SBC	HL,HL
	LEA	IY,IY+-36
	LD	SP,IY
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-39
	LD	BC,36
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkPieceMovement
	LD	IY,39
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_73
;  175	        return 1;
	LD	A,1
	JR	L_74
;  176	    }
L_73:
;  177	    return 0;
	XOR	A,A
;  178	}
L_74:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkMoveDown ***************************
;Name                         Addr/Register   Size   Type
;_checkPieceMovement                 IMPORT  -----   function
;checking_piece                       IX-39     36   variable
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 51 (bytes)
;       Spill Code: 0 (instruction)


;  179	
;  180	void verificationSuppressLine(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], uint32_t *score) {
_verificationSuppressLine:
	LD	HL,-4
	CALL	__frameset
;  181	    uint8_t i;
;  182	    uint8_t j;
;  183	    uint8_t line_count;
;  184	    uint8_t number_line_count;
;  185	
;  186	    number_line_count = 0;
	LD	(IX+-4),0
;  187	    for (i = 0; i < MATRIX_Y_LENGTH; i++) {
	LD	(IX+-1),0
	JR	L_87
L_85:
;  188	        line_count = 0;
	LD	(IX+-3),0
;  189	        for (j = 0; j < MATRIX_X_LENGTH; j++) {
	LD	(IX+-2),0
	JR	L_81
L_79:
;  190	            if (matrix[i][j] != WHITE) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	Z,L_80
;  191	                line_count++;
	INC	(IX+-3)
;  192	            }
;  193	        }
L_80:
	INC	(IX+-2)
L_81:
	LD	A,(IX+-2)
	CP	A,10
	JR	C,L_79
;  194	        if (line_count == MATRIX_X_LENGTH) {
	LD	A,(IX+-3)
	CP	A,10
	JR	NZ,L_86
;  195	            moveDownMatrix(matrix, i);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_moveDownMatrix
	POP	BC
	POP	BC
;  196	            number_line_count++;
	INC	(IX+-4)
;  197	        }
;  198	    }
L_86:
	INC	(IX+-1)
L_87:
	LD	A,(IX+-1)
	CP	A,20
	JR	C,L_85
;  199	    switch (number_line_count) {
	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	CALL	__seqcase
L__36:
	DW	4
	DW	1
	DB	0
	DW24	L_88	

	DW24	L_89	

	DW24	L_90	

	DW24	L_91	

	DW24	L_93	

;  200	        case 1 :
L_88:
;  201	            *score += 40;
	LD	IY,(IX+9)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	A,40
	CALL	__ladd_b
	LD	(IY),HL
	LD	(IY+3),E
;  202	            break;
	JR	L_93
;  203	        case 2 :
L_89:
;  204	            *score += 100;
	LD	IY,(IX+9)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	A,100
	CALL	__ladd_b
	LD	(IY),HL
	LD	(IY+3),E
;  205	            break;
	JR	L_93
;  206	        case 3 :
L_90:
;  207	            *score += 300;
	LD	IY,(IX+9)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,300
	XOR	A,A
	CALL	__ladd
	LD	(IY),HL
	LD	(IY+3),E
;  208	            break;
	JR	L_93
;  209	        case 4 :
L_91:
;  210	            *score += 1200;
	LD	IY,(IX+9)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,1200
	XOR	A,A
	CALL	__ladd
	LD	(IY),HL
	LD	(IY+3),E
;  211	            break;
;  212	    }
L_93:
;  213	    printScore(*score);
	LD	IY,(IX+9)
	LD	A,(IY+3)
	LD	H,0
	LD	L,A
	PUSH	HL
	LD	BC,(IY)
	PUSH	BC
	CALL	_printScore
	POP	BC
	POP	BC
;  214	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _verificationSuppressLine ***************************
;Name                         Addr/Register   Size   Type
;_printScore                         IMPORT  -----   function
;_moveDownMatrix                     IMPORT  -----   function
;number_line_count                     IX-4      1   variable
;line_count                            IX-3      1   variable
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;score                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


;  215	
;  216	void placePiece(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece, uint32_t *score) {
_placePiece:
	LD	HL,-6
	CALL	__frameset
;  217	    uint8_t i;
;  218	    t_pos piece_pos;
;  219	
;  220	    for (i = 0; i < SIZE_OF_PIECE; i++) {
	LD	(IX+-1),0
	JR	L_98
L_96:
;  221	        piece_pos.x = piece->pos.x + piece->rotation_pos[piece->rotation_state][i].x;
	LD	IY,(IX+9)
	LD	A,(IY+35)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IY+0
	ADD	HL,DE
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	A,(IY+32)
	LD	IY,(IX+-6)
	ADD	A,(IY+0)
	LD	(IX+-3),A
;  222	        piece_pos.y = piece->pos.y + piece->rotation_pos[piece->rotation_state][i].y;
	LD	IY,(IX+9)
	LD	A,(IY+33)
	LD	IY,(IX+-6)
	ADD	A,(IY+1)
	LD	(IX+-2),A
;  223	        matrix[piece_pos.y][piece_pos.x] = piece->color;
	SEXT	HL
	LD	L,(IX+-2)
	LD	A,10
	CALL	__imul_b
	LD	A,(IX+-3)
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	SEXT	HL
	LD	L,(IX+-3)
	ADD	HL,BC
	LD	IY,(IX+9)
	LD	A,(IY+34)
	LD	(HL),A
	INC	(IX+-1)
;  224	    }
L_98:
	LD	A,(IX+-1)
	CP	A,4
	JR	C,L_96
;  225	    printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  226	    free(piece);
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_free
	POP	BC
;  227	    verificationSuppressLine(matrix, score);
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_verificationSuppressLine
	POP	BC
	POP	BC
;  228	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _placePiece ***************************
;Name                         Addr/Register   Size   Type
;_verificationSuppressLine           IMPORT  -----   function
;_free                               IMPORT  -----   function
;_printPiece                         IMPORT  -----   function
;piece_pos                             IX-3      2   variable
;i                                     IX-1      1   variable
;score                                IX+12      3   parameter
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


;  229	
;  230	void drop(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece, uint32_t *score) {
_drop:
	LD	HL,-39
	CALL	__frameset
;  231	    t_piece checking_piece;
;  232	
;  233	    checking_piece = *piece;
	LEA	DE,IX+-36
	LD	HL,(IX+9)
	LD	BC,36
	LDIR	
;  234	
;  235	    while (checkPieceMovement(matrix, checking_piece)) {
	JR	L_103
L_104:
;  236	        checking_piece.pos.y++;
	LEA	BC,IX+-4
	LD	(IX+-39),BC
	LD	IY,(IX+-39)
	LD	A,(IY+1)
	INC	A
	LD	(IY+1),A
;  237	        if (checkPieceMovement(matrix, checking_piece)) {
	LD	IY,0
	ADD	IY,SP
	OR	A,A
	SBC	HL,HL
	LEA	IY,IY+-36
	LD	SP,IY
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-36
	LD	BC,36
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkPieceMovement
	LD	IY,39
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_103
;  238	            clearPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_clearPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  239	            *piece = checking_piece;
	LD	DE,(IX+9)
	LEA	HL,IX+-36
	LD	BC,36
	LDIR	
;  240	            printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+9)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  241	        }
;  242	    }
L_103:
	LD	IY,0
	ADD	IY,SP
	OR	A,A
	SBC	HL,HL
	LEA	IY,IY+-36
	LD	SP,IY
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-36
	LD	BC,36
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkPieceMovement
	LD	IY,39
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	NZ,L_104
;  243	    placePiece(matrix, piece, score);
	LD	BC,(IX+12)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_placePiece
	POP	BC
	POP	BC
	POP	BC
;  244	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drop ***************************
;Name                         Addr/Register   Size   Type
;_placePiece                         IMPORT  -----   function
;_printPiece                         IMPORT  -----   function
;_clearPiece                         IMPORT  -----   function
;_checkPieceMovement                 IMPORT  -----   function
;checking_piece                       IX-36     36   variable
;score                                IX+12      3   parameter
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 54 (bytes)
;       Spill Code: 0 (instruction)


;  245	
;  246	uint8_t checkEnd(t_piece piece) {
_checkEnd:
	LD	HL,-3
	CALL	__frameset
;  247	    uint8_t i;
;  248	    t_pos piece_pos;
;  249	    for (i = 0; i < SIZE_OF_PIECE; i++) {
	LD	(IX+-1),0
	JR	L_111
L_109:
;  250	        piece_pos.y = piece.pos.y + piece.rotation_pos[piece.rotation_state][i].y;
	LD	A,(IX+41)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IX+6
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IY+1)
	ADD	A,(IX+39)
	LD	(IX+-2),A
;  251	        if (piece_pos.y < 0) {
	OR	A,A
	JP	P,L_110
;  252	            return 1;
	LD	A,1
	JR	L_113
;  253	        }
;  254	    }
L_110:
	INC	(IX+-1)
L_111:
	LD	A,(IX+-1)
	CP	A,4
	JR	C,L_109
;  255	    return 0;
	XOR	A,A
;  256	}
L_113:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkEnd ***************************
;Name                         Addr/Register   Size   Type
;piece_pos                             IX-3      2   variable
;i                                     IX-1      1   variable
;piece                                 IX+6     36   parameter


; Stack Frame Size: 45 (bytes)
;       Spill Code: 0 (instruction)


;  257	
;  258	uint8_t checkKbAction(uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH], t_piece *piece, kb_key_t *old_key, uint32_t *score) {
_checkKbAction:
	LD	HL,-1
	CALL	__frameset
;  259	    kb_key_t key;
;  260	
;  261	    key = kb_Data[1];
	LD	A,(16056338)
	LD	(IX+-1),A
;  262	
;  263	    if (*old_key == key)
	LD	HL,(IX+12)
	LD	A,(HL)
	CP	A,(IX+-1)
	JR	NZ,L_115
;  264	        return 0;
	XOR	A,A
	JR	L_131
L_115:
;  265	
;  266	    *old_key = key;
	LD	HL,(IX+12)
	LD	A,(IX+-1)
	LD	(HL),A
;  267	
;  268	    switch (key) {
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	CALL	__case8
L__47:
	DW	7
	DB	1
	DW24	L_118	

	DB	2
	DW24	L_116	

	DB	4
	DW24	L_120	

	DB	8
	DW24	L_117	

	DB	16
	DW24	L_119	

	DB	32
	DW24	L_121	

	DB	64
	DW24	L_125	

	DW24	L_130	

;  269	        case kb_Trace :
L_116:
;  270	            moveRight(matrix, piece);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_moveRight
	POP	BC
	POP	BC
;  271	            break;
	JR	L_130
;  272	        case kb_Window :
L_117:
;  273	            moveLeft(matrix, piece);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_moveLeft
	POP	BC
	POP	BC
;  274	            break;
	JR	L_130
;  275	        case kb_Graph :
L_118:
;  276	            rightRotation(matrix, piece);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_rightRotation
	POP	BC
	POP	BC
;  277	            break;
	JR	L_130
;  278	        case kb_Yequ :
L_119:
;  279	            leftRotation(matrix, piece);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_leftRotation
	POP	BC
	POP	BC
;  280	            break;
	JR	L_130
;  281	        case kb_Zoom :
L_120:
;  282	            drop(matrix, piece, score);
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_drop
	POP	BC
	POP	BC
	POP	BC
;  283	            return 1;
	LD	A,1
	JR	L_131
;  284	        case kb_2nd :
L_121:
;  285	            if (checkMoveDown(matrix, piece)) {
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkMoveDown
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_123
;  286	                moveDown(matrix, piece);
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_moveDown
	POP	BC
	POP	BC
;  287	            } else {
	JR	L_130
L_123:
;  288	                placePiece(matrix, piece, score);
	LD	BC,(IX+15)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_placePiece
	POP	BC
	POP	BC
	POP	BC
;  289	                return 1;
	LD	A,1
	JR	L_131
;  290	            }
;  291	            break;
;  292	        case kb_Mode :
L_125:
;  293	            printPause();
	CALL	_printPause
;  294	            delay(1000);
	LD	BC,1000
	PUSH	BC
	CALL	_delay
	POP	BC
;  295	            do {
L_127:
;  296	                kb_Scan();
	CALL	_kb_Scan
;  297	            } while (!(kb_Data[1] & kb_Mode || kb_Data[1] & kb_Del));
	LD	A,(16056338)
	AND	A,64
	JR	NZ,L_129
	LD	A,(16056338)
	AND	A,128
	JR	Z,L_127
L_129:
;  298	            clearPause();
	CALL	_clearPause
;  299	            break;
;  300	    }
L_130:
;  301	    return 0;
	XOR	A,A
;  302	}
L_131:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkKbAction ***************************
;Name                         Addr/Register   Size   Type
;_clearPause                         IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;_delay                              IMPORT  -----   function
;_printPause                         IMPORT  -----   function
;_placePiece                         IMPORT  -----   function
;_moveDown                           IMPORT  -----   function
;_drop                               IMPORT  -----   function
;_leftRotation                       IMPORT  -----   function
;_rightRotation                      IMPORT  -----   function
;_moveLeft                           IMPORT  -----   function
;_moveRight                          IMPORT  -----   function
;key                                   IX-1      1   variable
;score                                IX+15      3   parameter
;old_key                              IX+12      3   parameter
;piece                                 IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


;  303	
;  304	void gameOver() {
_gameOver:
;  305	    printGameOver();
	CALL	_printGameOver
;  306	    while (!(kb_Data[1] & kb_Del)) {
	JR	L_132
L_133:
;  307	        kb_Scan();
	CALL	_kb_Scan
;  308	    }
L_132:
	LD	A,(16056338)
	AND	A,128
	JR	Z,L_133
;  309	}
	RET	


;**************************** _gameOver ***************************
;Name                         Addr/Register   Size   Type
;_kb_Scan                            IMPORT  -----   function
;_printGameOver                      IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  310	
;  311	uint8_t chooseDifficulty() {
_chooseDifficulty:
	LD	HL,-3
	CALL	__frameset
;  312	    uint8_t difficulty;
;  313	    kb_key_t key;
;  314	    kb_key_t old_key;
;  315	
;  316	    difficulty = NORMAL;
	LD	(IX+-1),1
;  317	    kb_Scan();
	CALL	_kb_Scan
;  318	    old_key = kb_Data[7];
	LD	A,(16056350)
	LD	(IX+-3),A
;  319	
;  320	    printDifficulty(difficulty);
	LD	BC,1
	PUSH	BC
	CALL	_printDifficulty
	POP	BC
;  321	    do {
L_145:
;  322	        kb_Scan();
	CALL	_kb_Scan
;  323	        key = kb_Data[7];
	LD	A,(16056350)
	LD	(IX+-2),A
;  324	
;  325	        if (key != old_key) {
	CP	A,(IX+-3)
	JR	Z,L_146
;  326	            old_key = key;
	LD	A,(IX+-2)
	LD	(IX+-3),A
;  327	            switch (key) {
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	CALL	__case8
L__55:
	DW	2
	DB	2
	DW24	L_139	

	DB	4
	DW24	L_135	

	DW24	L_146	

;  328	                case kb_Right :
L_135:
;  329	                    if (difficulty < HARD) {
	LD	A,(IX+-1)
	CP	A,2
	JR	NC,L_146
;  330	                        difficulty++;
	INC	(IX+-1)
;  331	                        printDifficulty(difficulty);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_printDifficulty
	POP	BC
;  332	                    }
;  333	                    break;
	JR	L_146
;  334	                case kb_Left :
L_139:
;  335	                    if (difficulty > EASY) {
	XOR	A,A
	CP	A,(IX+-1)
	JR	NC,L_146
;  336	                        difficulty--;
	DEC	(IX+-1)
;  337	                        printDifficulty(difficulty);
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	CALL	_printDifficulty
	POP	BC
;  338	                    }
;  339	                    break;
;  340	            }
;  341	        }
;  342	    } while (!(kb_Data[6] & kb_Enter || kb_Data[1] & kb_Del));
L_146:
	LD	A,(16056348)
	AND	A,1
	JR	NZ,L_147
	LD	A,(16056338)
	AND	A,128
	JR	Z,L_145
L_147:
;  343	    return difficulty;
	LD	A,(IX+-1)
;  344	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _chooseDifficulty ***************************
;Name                         Addr/Register   Size   Type
;_printDifficulty                    IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;old_key                               IX-3      1   variable
;key                                   IX-2      1   variable
;difficulty                            IX-1      1   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


;  345	
;  346	void loop(uint8_t difficulty) {
_loop:
	LD	HL,-251
	CALL	__frameset
;  347	    uint8_t matrix[MATRIX_Y_LENGTH][MATRIX_X_LENGTH];
;  348	    uint8_t end;
;  349	    uint32_t score;
;  350	    kb_key_t old_key;
;  351	    t_piece *piece;
;  352	    t_piece *next_piece;
;  353	    t_piece checking_piece;
;  354	
;  355	    old_key = 0;
	LD	(IX+-8),0
;  356	    end = 0;
	LD	(IX+-7),0
;  357	    score = 0;
	LD	BC,0
	LD	(IX+-12),BC
	XOR	A,A
	LD	(IX+-9),A
;  358	
;  359	    gfx_FillScreen(BLACK);
	LD	BC,25
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  360	
;  361	    printScore(score);
	LD	C,(IX+-9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_printScore
	POP	BC
	POP	BC
;  362	
;  363	    initMatrix(matrix);
	LD	HL,IX
	LD	BC,-248
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_initMatrix
	POP	BC
;  364	    printScreen(matrix);
	LD	HL,IX
	LD	BC,-248
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_printScreen
	POP	BC
;  365	
;  366	    if (!(piece = createPiece()))
	CALL	_createPiece
	LD	(IX+-3),HL
	CALL	__icmpzero
	JR	Z,L_171
;  367	        return;
;  368	    if (!(next_piece = createPiece()))
	CALL	_createPiece
	LD	(IX+-6),HL
	CALL	__icmpzero
	JR	Z,L_171
;  369	        return;
;  370	
;  371	    printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+-3)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  372	    printNextPiece(*next_piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+-6)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printNextPiece
	LD	IY,36
;  373	
;  374	    timer_Control = TIMER1_DISABLE;
	LD	HL,15859760
	LD	(HL),0
	ADD	IY,SP
	LD	SP,IY
	INC	HL
	LD	(HL),0
;  375	    timer_1_ReloadValue = timer_1_Counter = TIMER[difficulty];
	LD	A,(IX+6)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_TIMER
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	(15859712),HL
	XOR	A,A
	LD	(15859715),A
	LD	BC,(15859712)
	LD	A,(15859715)
	LD	(15859716),BC
	LD	(15859719),A
;  376	    timer_Control = TIMER1_ENABLE | TIMER1_32K | TIMER1_0INT | TIMER1_DOWN;
	LD	HL,15859760
	LD	(HL),7
	INC	HL
	LD	(HL),0
;  377	
;  378	    do {
L_166:
;  379	        kb_Scan();
	CALL	_kb_Scan
;  380	        if (checkKbAction(matrix, piece, &old_key, &score)) {
	PEA	IX+-12
	PEA	IX+-8
	LD	BC,(IX+-3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-248
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_checkKbAction
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_164
;  381	            timer_IntAcknowledge = TIMER1_RELOADED;
	LD	HL,15859764
	LD	(HL),4
	INC	HL
	LD	(HL),0
;  382	
;  383	            piece = next_piece;
	LD	BC,(IX+-6)
	LD	(IX+-3),BC
;  384	            if (!(next_piece = createPiece()))
	CALL	_createPiece
	LD	(IX+-6),HL
	CALL	__icmpzero
	JR	Z,L_171
;  385	                return;
;  386	            printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+-3)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  387	            printNextPiece(*next_piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+-6)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printNextPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  388	        }
L_164:
;  389	
;  390	        if (timer_IntStatus & TIMER1_RELOADED) {
	LD	A,(15859764)
	AND	A,4
	LD	C,A
	LD	B,0
	LD	HL,BC
	CALL	__scmpzero
	JR	Z,L_167
;  391	            timer_IntAcknowledge = TIMER1_RELOADED;
	LD	HL,15859764
	LD	(HL),4
	INC	HL
	LD	(HL),0
;  392	
;  393	            checking_piece = *piece;
	LD	HL,(IX+-3)
	LEA	DE,IX+-48
	LD	BC,36
	LDIR	
;  394	            checking_piece.pos.y++;
	LEA	BC,IX+-16
	LEA	IY,IX+-128
	LD	(IY+-123),BC
	LD	BC,(IY+-123)
	LD	DE,(IY+-123)
	LD	IY,BC
	LD	A,(IY+1)
	INC	A
	LD	IY,DE
	LD	(IY+1),A
;  395	
;  396	            if (checkPieceMovement(matrix, checking_piece)) {
	LD	IY,0
	ADD	IY,SP
	OR	A,A
	SBC	HL,HL
	LD	BC,36
	LEA	IY,IY+-36
	LD	SP,IY
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-48
	LDIR	
	LD	HL,IX
	LD	BC,-248
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_checkPieceMovement
	LD	IY,39
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_162
;  397	                moveDown(matrix, piece);
	LD	BC,(IX+-3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-248
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_moveDown
	POP	BC
	POP	BC
;  398	            } else if (checkEnd(*piece)) {
	JR	L_167
L_162:
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+-3)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_checkEnd
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_160
;  399	                end = 1;
	LD	(IX+-7),1
;  400	            } else {
	JR	L_167
L_160:
;  401	                placePiece(matrix, piece, &score);
	PEA	IX+-12
	LD	BC,(IX+-3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-248
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_placePiece
	POP	BC
	POP	BC
	POP	BC
;  402	                piece = next_piece;
	LD	BC,(IX+-6)
	LD	(IX+-3),BC
;  403	                if (!(next_piece = createPiece()))
	CALL	_createPiece
	LD	(IX+-6),HL
	CALL	__icmpzero
	JR	Z,L_171
;  404	                    return;
;  405	                printPiece(*piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+-3)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  406	                printNextPiece(*next_piece);
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-36
	LD	HL,(IX+-6)
	LD	SP,IY
	LD	IY,0
	ADD	IY,SP
	LD	DE,IY
	LD	BC,36
	LDIR	
	CALL	_printNextPiece
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
;  407	            }
;  408	        }
;  409	    } while (!(kb_Data[1] & kb_Del || end));
L_167:
	LD	A,(16056338)
	AND	A,128
	JR	NZ,L_169
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_166
L_169:
;  410	
;  411	    if (end) {
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_170
;  412	        gameOver();
	CALL	_gameOver
;  413	    }
L_170:
;  414	
;  415	    free(piece);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free
	POP	BC
;  416	    free(next_piece);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free
	POP	BC
;  417	}
L_171:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _loop ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_gameOver                           IMPORT  -----   function
;_placePiece                         IMPORT  -----   function
;_checkEnd                           IMPORT  -----   function
;_moveDown                           IMPORT  -----   function
;_checkPieceMovement                 IMPORT  -----   function
;_checkKbAction                      IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;_TIMER                              STATIC      6   variable
;_printNextPiece                     IMPORT  -----   function
;_printPiece                         IMPORT  -----   function
;_createPiece                        IMPORT  -----   function
;_printScreen                        IMPORT  -----   function
;_initMatrix                         IMPORT  -----   function
;_printScore                         IMPORT  -----   function
;_gfx_FillScreen                     IMPORT  -----   function
;matrix                              IX-248    200   variable
;checking_piece                       IX-48     36   variable
;score                                IX-12      4   variable
;old_key                               IX-8      1   variable
;end                                   IX-7      1   variable
;next_piece                            IX-6      3   variable
;piece                                 IX-3      3   variable
;difficulty                            IX+6      1   parameter


; Stack Frame Size: 260 (bytes)
;       Spill Code: 0 (instruction)


	XREF _printGameOver:ROM
	XREF _clearPause:ROM
	XREF _printPause:ROM
	XREF _printDifficulty:ROM
	XREF _printScore:ROM
	XREF _printNextPiece:ROM
	XREF _clearPiece:ROM
	XREF _printPiece:ROM
	XREF _printScreen:ROM
	XREF _PIECE_6:ROM
	XREF _PIECE_5:ROM
	XREF _PIECE_4:ROM
	XREF _PIECE_3:ROM
	XREF _PIECE_2:ROM
	XREF _PIECE_1:ROM
	XREF _PIECE_0:ROM
	XREF _gfx_FillScreen:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _delay:ROM
	XREF _random:ROM
	XREF _kb_Scan:ROM
	XREF __ladd:ROM
	XREF __iremu:ROM
	XREF __stoiu:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __case8:ROM
	XREF __seqcase:ROM
	XREF __imul_b:ROM
	XREF __ladd_b:ROM
	XDEF _loop
	XDEF _chooseDifficulty
	XDEF _gameOver
	XDEF _checkKbAction
	XDEF _checkEnd
	XDEF _drop
	XDEF _placePiece
	XDEF _verificationSuppressLine
	XDEF _checkMoveDown
	XDEF _moveDownMatrix
	XDEF _moveDown
	XDEF _rightRotation
	XDEF _leftRotation
	XDEF _moveRight
	XDEF _moveLeft
	XDEF _initMatrix
	XDEF _checkPieceMovement
	XDEF _checkCaseMovement
	XDEF _createPiece
	XDEF _TIMER
	END
