; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\CORE.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "NONAME0",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME0"
.TYPE 8
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME1"
.TYPE 104
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME0"
.TYPE 104
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME7"
.BEGREC "font",12
.DEFINE "font"
.VALUE 0
.CLASS 8
.TAG "font"
.TYPE 40
.ENDEF
.DEFINE "drawChar"
.VALUE 3
.CLASS 8
.TYPE 545
.ENDEF
.DEFINE "getWidth"
.VALUE 6
.CLASS 8
.TYPE 558
.ENDEF
.DEFINE "getHeight"
.VALUE 9
.CLASS 8
.TYPE 558
.ENDEF
.ENDREC "font"
.BEGREC "NONAME8",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME10"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME10",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME10"
.BEGREC "NONAME11",3
.DEFINE "width"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME11"
.BEGREC "NONAME12",3
.DEFINE "width"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME12"
.BEGREC "NONAME13",6
.DEFINE "x"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "y"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME13"
.BEGREC "NONAME14",12
.DEFINE "xmin"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ymin"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "xmax"
.VALUE 6
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ymax"
.VALUE 9
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME14"
.BEGREC "NONAME15",18
.DEFINE "map"
.VALUE 0
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "tiles"
.VALUE 3
.CLASS 8
.TAG "NONAME11"
.TYPE 296
.ENDEF
.DEFINE "tile_height"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "tile_width"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "draw_height"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "draw_width"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "type_width"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "type_height"
.VALUE 11
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 12
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "width"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "y_loc"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "x_loc"
.VALUE 15
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME15"
.BEGREC "s_pos",4
.DEFINE "x"
.VALUE 0
.CLASS 8
.TYPE 3
.ENDEF
.DEFINE "y"
.VALUE 2
.CLASS 8
.TYPE 3
.ENDEF
.ENDREC "s_pos"
.BEGREC "s_cursor",5
.DEFINE "pos"
.VALUE 0
.CLASS 8
.TAG "s_pos"
.TYPE 8
.ENDEF
.DEFINE "state"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "s_cursor"
.BEGREC "s_case",3
.DEFINE "number"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "old_number"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "id"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "s_case"
.BEGREC "s_game",1810
.DEFINE "x_max"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "y_max"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "matrix"
.VALUE 2
.CLASS 8
.DIM 30
.DIM 20
.TAG "s_case"
.TYPE 872
.ENDEF
.DEFINE "number_max"
.VALUE 1802
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "amount_number"
.VALUE 1803
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "win"
.VALUE 1804
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cursor"
.VALUE 1805
.CLASS 8
.TAG "s_cursor"
.TYPE 8
.ENDEF
.ENDREC "s_game"
;    1	
;    2	#include "core.h"
;    3	
;    4	void setFirstNumber(t_game *game, t_pos *first_number) {
_setFirstNumber:
.DEFINE "_setFirstNumber"

.VALUE _setFirstNumber

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setFirstNumber",4,"_setFirstNumber"

.LINE 4

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "first_number"

.CLASS 65

.VALUE 9

.TAG "s_pos"

.TYPE 40

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "breaking"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;    5	    uint8_t i;
;    6	    uint8_t j;
;    7	    uint8_t breaking;
;    8	
;    9	    breaking = FALSE;
.LINE 9

	LD	(IX+-3),0
;   10	
;   11	    for (i = 0; i < game->x_max; ++i) {
.LINE 11

	LD	(IX+-1),0
	JR	L_8
L_6:
;   12	        for (j = 0; j < game->y_max; ++j) {
.LINE 12

	LD	(IX+-2),0
	JR	L_3
L_1:
;   13	            if (game->matrix[i][j].number > CASE_EMPTY) {
.LINE 13

	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	XOR	A,A
	LD	IY,HL
	CP	A,(IY+0)
	CALL	__setflag
	JP	P,L_2
;   14	                breaking = TRUE;
.LINE 14

	LD	(IX+-3),1
;   15	                break;
.LINE 15

	JR	L_5
;   16	            }
;   17	        }
L_2:
.LINE 17

	INC	(IX+-2)
L_3:
	LD	A,(IX+-2)
	LD	IY,(IX+6)
	CP	A,(IY+1)
	JR	C,L_1
L_5:
;   18	        if (breaking) { break; }
.LINE 18

	LD	A,(IX+-3)
	OR	A,A
	JR	NZ,L_9
	INC	(IX+-1)
;   19	    }
L_8:
.LINE 19

	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+0)
	JR	C,L_6
L_9:
;   20	    i %= MATRIX_X_MAX;
.LINE 20

	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,30
	CALL	__irems
	LD	(IX+-1),L
;   21	    j %= MATRIX_Y_MAX;
.LINE 21

	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,20
	CALL	__irems
	LD	(IX+-2),L
;   22	
;   23	    first_number->x = i;
.LINE 23

	LD	C,(IX+-1)
	LD	B,0
	LD	IY,(IX+9)
	LD	(IY+0),C
	LD	(IY+1),B
;   24	    first_number->y = j;
.LINE 24

	LD	C,(IX+-2)
	LD	(IY+2),C
	LD	(IY+3),B
;   25	}
.LINE 25

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setFirstNumber ***************************
;Name                         Addr/Register   Size   Type
;breaking                              IX-3      1   variable
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;first_number                          IX+9      3   parameter
;game                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setFirstNumber",25,"_setFirstNumber"
;   26	
;   27	void initCursor(t_game *game) {
_initCursor:
.DEFINE "_initCursor"

.VALUE _initCursor

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initCursor",27,"_initCursor"

.LINE 27

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "first_number"

.CLASS 65

.VALUE -4

.TAG "s_pos"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   28	    t_pos first_number;
;   29	
;   30	    setFirstNumber(game, &first_number);
.LINE 30

	PEA	IX+-4
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_setFirstNumber
	POP	BC
	POP	BC
;   31	
;   32	    game->cursor.pos.x = first_number.x;
.LINE 32

	LD	HL,(IX+-4)
	LD	BC,1805
	LD	IY,(IX+6)
	CALL	__sstiy
;   33	    game->cursor.pos.y = first_number.y;
.LINE 33

	LD	HL,(IX+-2)
	LD	BC,1807
	CALL	__sstiy
;   34	    game->cursor.state = 0;
.LINE 34

	XOR	A,A
	LD	BC,1809
	CALL	__bstiy
;   35	}
.LINE 35

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initCursor ***************************
;Name                         Addr/Register   Size   Type
;first_number                          IX-4      4   variable
;game                                  IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initCursor",35,"_initCursor"
;   36	
;   37	uint8_t cursorCanMove(t_game *game, int8_t increment_x, int8_t increment_y) {
_cursorCanMove:
.DEFINE "_cursorCanMove"

.VALUE _cursorCanMove

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "cursorCanMove",37,"_cursorCanMove"

.LINE 37

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "increment_x"

.CLASS 65

.VALUE 9

.TYPE 2

.ENDEF

.DEFINE "increment_y"

.CLASS 65

.VALUE 12

.TYPE 2

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   38	    if (game->cursor.pos.x + increment_x >= game->x_max || game->cursor.pos.x + increment_x < 0)
.LINE 38

	LD	BC,1805
	LD	IY,(IX+6)
	CALL	__sldiy
	LD	BC,HL
	CALL	__stoi
	LD	BC,HL
	LD	A,(IX+9)
	SEXT	HL
	LD	L,(IX+9)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IY+0)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	JP	P,L_13
	LD	BC,1805
	LD	IY,(IX+6)
	CALL	__sldiy
	LD	BC,HL
	CALL	__stoi
	LD	BC,HL
	LD	A,(IX+9)
	SEXT	HL
	LD	L,(IX+9)
	ADD	HL,BC
	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_16
L_13:
;   39	        return FALSE;
.LINE 39

	XOR	A,A
	JR	L_20
L_16:
;   40	    if (game->cursor.pos.y + increment_y >= game->y_max || game->cursor.pos.y + increment_y < 0)
.LINE 40

	LD	BC,1807
	LD	IY,(IX+6)
	CALL	__sldiy
	LD	BC,HL
	CALL	__stoi
	LD	BC,HL
	LD	A,(IX+12)
	SEXT	HL
	LD	L,(IX+12)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IY+1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_15
	LD	BC,1807
	LD	IY,(IX+6)
	CALL	__sldiy
	LD	BC,HL
	CALL	__stoi
	LD	BC,HL
	LD	A,(IX+12)
	SEXT	HL
	LD	L,(IX+12)
	ADD	HL,BC
	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_18
L_15:
;   41	        return FALSE;
.LINE 41

	XOR	A,A
	JR	L_20
L_18:
;   42	    if (game->matrix[game->cursor.pos.x + increment_x][game->cursor.pos.y + increment_y].number == CASE_BLOCKED)
.LINE 42

	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(IX+-3),HL
	LD	IY,(IX+-3)
	LD	BC,(IY+0)
	CALL	__stoi
	LD	BC,HL
	LD	A,(IX+9)
	SEXT	HL
	LD	L,(IX+9)
	ADD	HL,BC
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	IY,(IX+-3)
	LD	BC,(IY+2)
	CALL	__stoi
	LD	BC,HL
	LD	A,(IX+12)
	SEXT	HL
	LD	L,(IX+12)
	ADD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	A,(IY+0)
	CP	A,-2
	JR	NZ,L_19
;   43	        return FALSE;
.LINE 43

	XOR	A,A
	JR	L_20
L_19:
;   44	    return TRUE;
.LINE 44

	LD	A,1
;   45	}
L_20:
.LINE 45

	LD	SP,IX
	POP	IX
	RET	


;**************************** _cursorCanMove ***************************
;Name                         Addr/Register   Size   Type
;increment_y                          IX+12      1   parameter
;increment_x                           IX+9      1   parameter
;game                                  IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "cursorCanMove",45,"_cursorCanMove"
;   46	
;   47	void moveCursor(t_game *game, int8_t increment_x, int8_t increment_y) {
_moveCursor:
.DEFINE "_moveCursor"

.VALUE _moveCursor

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "moveCursor",47,"_moveCursor"

.LINE 47

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "increment_x"

.CLASS 65

.VALUE 9

.TYPE 2

.ENDEF

.DEFINE "increment_y"

.CLASS 65

.VALUE 12

.TYPE 2

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   48	    if (!cursorCanMove(game, increment_x, increment_y)) { return; }
.LINE 48

	LD	C,(IX+12)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_cursorCanMove
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_23
;   49	
;   50	    eraseCursor(game);
.LINE 50

	LD	BC,(IX+6)
	PUSH	BC
	CALL	_eraseCursor
	POP	BC
;   51	    game->cursor.pos.x += increment_x;
.LINE 51

	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(IX+-3),HL
	LD	A,(IX+9)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,1805
	LD	DE,(IX+6)
	ADD	HL,DE
	LD	HL,(HL)
	ADD.SIS	HL,BC
	LD	IY,(IX+-3)
	LD	BC,HL
	LD	(IY+0),C
	LD	(IY+1),B
;   52	    game->cursor.pos.y += increment_y;
.LINE 52

	LD	A,(IX+12)
	LD	D,A
	SEXT	HL
	LD	L,D
	LD	DE,HL
	LD	HL,(IY+2)
	ADD.SIS	HL,DE
	LD	BC,HL
	LD	(IY+2),C
	LD	(IY+3),B
;   53	    printCursor(game->cursor);
.LINE 53

	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,5
	LDIR	
	CALL	_printCursor
	POP	BC
	POP	BC
;   54	    delay(WAITING_DELAY);
.LINE 54

	LD	BC,250
	PUSH	BC
	CALL	_delay
	POP	BC
;   55	}
L_23:
.LINE 55

	LD	SP,IX
	POP	IX
	RET	


;**************************** _moveCursor ***************************
;Name                         Addr/Register   Size   Type
;_delay                              IMPORT  -----   function
;_printCursor                        IMPORT  -----   function
;_eraseCursor                        IMPORT  -----   function
;increment_y                          IX+12      1   parameter
;increment_x                           IX+9      1   parameter
;game                                  IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "moveCursor",55,"_moveCursor"
;   56	
;   57	void kbArrowMove(t_game *game) {
_kbArrowMove:
.DEFINE "_kbArrowMove"

.VALUE _kbArrowMove

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "kbArrowMove",57,"_kbArrowMove"

.LINE 57

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "key"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;   58	    kb_key_t key = kb_Data[7];
.LINE 58

	LD	A,(16056350)
	LD	(IX+-1),A
;   59	
;   60	    if (key & kb_Down)
.LINE 60

	AND	A,1
	JR	Z,L_26
;   61	        moveCursor(game, DOWN);
.LINE 61

	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_moveCursor
	POP	BC
	POP	BC
	POP	BC
L_26:
;   62	    if (key & kb_Up)
.LINE 62

	LD	A,(IX+-1)
	AND	A,8
	JR	Z,L_28
;   63	        moveCursor(game, UP);
.LINE 63

	LD	BC,16777215
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_moveCursor
	POP	BC
	POP	BC
	POP	BC
L_28:
;   64	    if (key & kb_Left)
.LINE 64

	LD	A,(IX+-1)
	AND	A,2
	JR	Z,L_30
;   65	        moveCursor(game, LEFT);
.LINE 65

	LD	BC,0
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_moveCursor
	POP	BC
	POP	BC
	POP	BC
L_30:
;   66	    if (key & kb_Right)
.LINE 66

	LD	A,(IX+-1)
	AND	A,4
	JR	Z,L_31
;   67	        moveCursor(game, RIGHT);
.LINE 67

	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_moveCursor
	POP	BC
	POP	BC
	POP	BC
;   68	}
L_31:
.LINE 68

	LD	SP,IX
	POP	IX
	RET	


;**************************** _kbArrowMove ***************************
;Name                         Addr/Register   Size   Type
;key                                   IX-1      1   variable
;game                                  IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "kbArrowMove",68,"_kbArrowMove"
;   69	
;   70	uint8_t checkGameWin(t_game *game) {
_checkGameWin:
.DEFINE "_checkGameWin"

.VALUE _checkGameWin

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "checkGameWin",70,"_checkGameWin"

.LINE 70

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   71	    uint8_t i;
;   72	    uint8_t j;
;   73	
;   74	    for (i = 0; i < game->x_max; ++i) {
.LINE 74

	LD	(IX+-1),0
	JR	L_38
L_36:
;   75	        for (j = 0; j < game->y_max; ++j) {
.LINE 75

	LD	(IX+-2),0
	JR	L_35
L_33:
;   76	            if (game->matrix[i][j].number > CASE_USED)
.LINE 76

	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	A,255
	LD	IY,HL
	CP	A,(IY+0)
	JP	P,L_34
;   77	                return FALSE;
.LINE 77

	XOR	A,A
	JR	L_40
;   78	        }
L_34:
.LINE 78

	INC	(IX+-2)
L_35:
	LD	A,(IX+-2)
	LD	IY,(IX+6)
	CP	A,(IY+1)
	JR	C,L_33
	INC	(IX+-1)
;   79	    }
L_38:
.LINE 79

	LD	A,(IX+-1)
	LD	IY,(IX+6)
	CP	A,(IY+0)
	JR	C,L_36
;   80	    return TRUE;
.LINE 80

	LD	A,1
;   81	}
L_40:
.LINE 81

	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkGameWin ***************************
;Name                         Addr/Register   Size   Type
;j                                     IX-2      1   variable
;i                                     IX-1      1   variable
;game                                  IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "checkGameWin",81,"_checkGameWin"
;   82	
;   83	uint8_t isInMap(t_game *game, t_pos pos) {
_isInMap:
.DEFINE "_isInMap"

.VALUE _isInMap

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "isInMap",83,"_isInMap"

.LINE 83

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "pos"

.CLASS 65

.VALUE 9

.TAG "s_pos"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   84	    if (pos.x >= 0 && pos.x < game->x_max && pos.y >= 0 && pos.y < game->y_max) { return TRUE; }
.LINE 84

	LD	HL,(IX+9)
	CALL	__scmpzero
	CALL	__setflag
	JP	M,L_45
	LD	BC,(IX+9)
	CALL	__stoi
	LD	DE,HL
	LD	IY,(IX+6)
	LD	A,(IY+0)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_45
	LD	HL,(IX+11)
	CALL	__scmpzero
	CALL	__setflag
	JP	M,L_45
	LD	BC,(IX+11)
	CALL	__stoi
	LD	DE,HL
	LD	IY,(IX+6)
	LD	A,(IY+1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_45
	LD	A,1
	JR	L_46
L_45:
;   85	    return FALSE;
.LINE 85

	XOR	A,A
;   86	}
L_46:
.LINE 86

	LD	SP,IX
	POP	IX
	RET	


;**************************** _isInMap ***************************
;Name                         Addr/Register   Size   Type
;pos                                   IX+9      4   parameter
;game                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "isInMap",86,"_isInMap"
;   87	
;   88	uint8_t checkPlacement(t_game *game, t_pos pos, int8_t increment_x, int8_t increment_y) {
_checkPlacement:
.DEFINE "_checkPlacement"

.VALUE _checkPlacement

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "checkPlacement",88,"_checkPlacement"

.LINE 88

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "pos"

.CLASS 65

.VALUE 9

.TAG "s_pos"

.TYPE 8

.ENDEF

.DEFINE "increment_x"

.CLASS 65

.VALUE 15

.TYPE 2

.ENDEF

.DEFINE "increment_y"

.CLASS 65

.VALUE 18

.TYPE 2

.ENDEF

.DEFINE "number"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
	DEC	SP
;   89	    uint8_t number;
;   90	
;   91	    number = game->matrix[pos.x][pos.y].number;
.LINE 91

	LD	BC,(IX+9)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+11)
	CALL	__stoi
	LD	(IX+-4),BC	; spill
	LD	(IX+-10),HL	; spill
	LD	BC,(IX+-4)	; unspill
	ADD	HL,HL
	LD	(IX+-4),BC	; spill
	LD	BC,(IX+-10)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-4)	; unspill
	ADD	HL,DE
	LD	IY,HL
	LD	A,(IY+0)
	LD	(IX+-1),A
;   92	
;   93	    while (isInMap(game, pos) && number) {
.LINE 93

	JR	L_51
L_52:
;   94	        pos.x += increment_x;
.LINE 94

	LD	A,(IX+15)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,(IX+9)
	ADD.SIS	HL,BC
	LD	(IX+9),L
	LD	(IX+10),H
;   95	        pos.y += increment_y;
.LINE 95

	LD	A,(IX+18)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,(IX+11)
	ADD.SIS	HL,BC
	LD	(IX+11),L
	LD	(IX+12),H
;   96	        if (game->matrix[pos.x][pos.y].number <= CASE_BLOCKED) { break; }
.LINE 96

	LD	BC,(IX+9)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+11)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	A,254
	LD	IY,HL
	CP	A,(IY+0)
	CALL	__setflag
	JP	P,L_54
;   97	        if (!(game->matrix[pos.x][pos.y].number)) { --number; }
.LINE 97

	LD	BC,(IX+9)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+11)
	CALL	__stoi
	LD	(IX+-4),BC	; spill
	LD	(IX+-7),HL	; spill
	LD	BC,(IX+-4)	; unspill
	ADD	HL,HL
	LD	(IX+-4),BC	; spill
	LD	BC,(IX+-7)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-4)	; unspill
	ADD	HL,DE
	LD	IY,HL
	LD	A,(IY+0)
	OR	A,A
	JR	NZ,L_51
	DEC	(IX+-1)
;   98	    }
L_51:
.LINE 98

	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+9
	LD	BC,4
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_isInMap
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_54
	LD	A,(IX+-1)
	OR	A,A
	JR	NZ,L_52
L_54:
;   99	    if (!number) { return TRUE; }
.LINE 99

	LD	A,(IX+-1)
	OR	A,A
	JR	NZ,L_55
	LD	A,1
	JR	L_56
L_55:
;  100	    return FALSE;
.LINE 100

	XOR	A,A
;  101	}
L_56:
.LINE 101

	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkPlacement ***************************
;Name                         Addr/Register   Size   Type
;_isInMap                            IMPORT  -----   function
;number                                IX-1      1   variable
;increment_y                          IX+18      1   parameter
;increment_x                          IX+15      1   parameter
;pos                                   IX+9      4   parameter
;game                                  IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "checkPlacement",101,"_checkPlacement"
;  102	
;  103	void placement(t_game *game, int8_t increment_x, int8_t increment_y) {
_placement:
.DEFINE "_placement"

.VALUE _placement

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "placement",103,"_placement"

.LINE 103

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "increment_x"

.CLASS 65

.VALUE 9

.TYPE 2

.ENDEF

.DEFINE "increment_y"

.CLASS 65

.VALUE 12

.TYPE 2

.ENDEF

.DEFINE "pos"

.CLASS 65

.VALUE -4

.TAG "s_pos"

.TYPE 8

.ENDEF

.DEFINE "number"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "id"

.CLASS 65

.VALUE -9

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-12
	LD	SP,HL
;  104	    uint8_t number;
;  105	    t_pos pos;
;  106	    uint8_t id;
;  107	
;  108	    pos.x = game->cursor.pos.x;
.LINE 108

	LD	BC,1805
	LD	IY,(IX+6)
	CALL	__sldiy
	LD	(IX+-4),L
	LD	(IX+-3),H
;  109	    pos.y = game->cursor.pos.y;
.LINE 109

	LD	BC,1807
	CALL	__sldiy
	LD	(IX+-2),L
	LD	(IX+-1),H
;  110	
;  111	    if (!checkPlacement(game, pos, increment_x, increment_y)) { return; }
.LINE 111

	LD	C,(IX+12)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-4
	LD	BC,4
	LDIR	
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkPlacement
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	Z,L_63
;  112	
;  113	    number = game->matrix[pos.x][pos.y].number;
.LINE 113

	LD	BC,(IX+-4)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	A,(IY+0)
	LD	(IX+-8),A
;  114	    id = game->matrix[pos.x][pos.y].id;
.LINE 114

	LD	BC,(IX+-4)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	A,(IY+2)
	LD	(IX+-9),A
;  115	    game->matrix[pos.x][pos.y].number = CASE_USED;
.LINE 115

	LD	IY,(IX+6)
	LEA	BC,IY+2
	LD	(IX+-12),BC
	LD	BC,(IX+-4)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	(IY+0),255
;  116	    printCase(game->matrix, pos.x, pos.y);
.LINE 116

	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-4)
	PUSH	BC
	LD	IY,(IX+6)
	PEA	IY+2
	CALL	_printCase
	POP	BC
	POP	BC
	POP	BC
;  117	    delay(50);
.LINE 117

	LD	BC,50
	PUSH	BC
	CALL	_delay
	POP	BC
;  118	
;  119	    while (number) {
.LINE 119

	JR	L_60
L_61:
;  120	        pos.x += increment_x;
.LINE 120

	LD	A,(IX+9)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,(IX+-4)
	ADD.SIS	HL,BC
	LD	(IX+-4),L
	LD	(IX+-3),H
;  121	        pos.y += increment_y;
.LINE 121

	LD	A,(IX+12)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,(IX+-2)
	ADD.SIS	HL,BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;  122	        if (!(game->matrix[pos.x][pos.y].number)) {
.LINE 122

	LD	BC,(IX+-12)
	LD	(IX+-7),BC
	LD	BC,(IX+-4)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,(IX+-7)
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	A,(IY+0)
	OR	A,A
	JR	NZ,L_60
;  123	            game->matrix[pos.x][pos.y].number = CASE_USED;
.LINE 123

	LD	BC,(IX+-7)
	LD	(IX+-12),BC
	LD	BC,(IX+-4)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,(IX+-7)
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	(IY+0),255
;  124	            game->matrix[pos.x][pos.y].id = id;
.LINE 124

	LD	BC,(IX+-4)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,(IX+-7)
	ADD	HL,BC
	LD	DE,HL
	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	A,(IX+-9)
	LD	IY,HL
	LD	(IY+2),A
;  125	            printCase(game->matrix, pos.x, pos.y);
.LINE 125

	LD	C,(IX+-2)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-4)
	PUSH	BC
	LD	BC,(IX+-7)
	PUSH	BC
	CALL	_printCase
	POP	BC
	POP	BC
	POP	BC
;  126	            --number;
.LINE 126

	DEC	(IX+-8)
;  127	            delay(50);
.LINE 127

	LD	BC,50
	PUSH	BC
	CALL	_delay
	POP	BC
;  128	        }
;  129	    }
L_60:
.LINE 129

	LD	A,(IX+-8)
	OR	A,A
	JR	NZ,L_61
;  130	    game->cursor.state = 0;
.LINE 130

	XOR	A,A
	LD	BC,1809
	LD	IY,(IX+6)
	CALL	__bstiy
;  131	    printCursor(game->cursor);
.LINE 131

	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,5
	LDIR	
	CALL	_printCursor
	POP	BC
	POP	BC
;  132	    delay(WAITING_DELAY);
.LINE 132

	LD	BC,250
	PUSH	BC
	CALL	_delay
	POP	BC
;  133	    game->win = checkGameWin(game);
.LINE 133

	LD	BC,(IX+6)
	PUSH	BC
	CALL	_checkGameWin
	POP	BC
	LD	BC,1804
	LD	IY,(IX+6)
	CALL	__bstiy
;  134	}
L_63:
.LINE 134

	LD	SP,IX
	POP	IX
	RET	


;**************************** _placement ***************************
;Name                         Addr/Register   Size   Type
;_printCursor                        IMPORT  -----   function
;_delay                              IMPORT  -----   function
;_printCase                          IMPORT  -----   function
;G_5                                  IX-12      3   variable
;id                                    IX-9      1   variable
;number                                IX-8      1   variable
;G_6                                   IX-7      3   variable
;pos                                   IX-4      4   variable
;increment_y                          IX+12      1   parameter
;increment_x                           IX+9      1   parameter
;game                                  IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "placement",134,"_placement"
;  135	
;  136	void undo(t_game *game) {
_undo:
.DEFINE "_undo"

.VALUE _undo

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "undo",136,"_undo"

.LINE 136

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "id"

.CLASS 65

.VALUE -6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-15
	LD	SP,HL
;  137	    uint8_t i;
;  138	    uint8_t j;
;  139	    uint8_t id;
;  140	
;  141	    id = game->matrix[game->cursor.pos.x][game->cursor.pos.y].id;
.LINE 141

	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(IX+-3),HL
	LD	IY,(IX+-3)
	LD	BC,(IY+0)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	IY,(IX+-3)
	LD	BC,(IY+2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	LD	IY,HL
	LD	A,(IY+2)
	LD	(IX+-6),A
;  142	
;  143	    if (!id) { return; }
.LINE 143

	OR	A,A
	JR	Z,L_74
;  144	
;  145	    for (i = 0; i < game->x_max; ++i) {
.LINE 145

	LD	(IX+-4),0
	JR	L_71
L_69:
;  146	        for (j = 0; j < game->y_max; ++j) {
.LINE 146

	LD	(IX+-5),0
	JR	L_68
L_66:
;  147	            if (game->matrix[i][j].id == id) {
.LINE 147

	LD	A,(IX+-4)
	UEXT	HL
	LD	L,A
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	(IX+-12),HL
	LD	A,(IX+-5)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+-12)
	ADD	HL,BC
	LD	(IX+-15),HL
	LD	(IX+-9),HL
	LD	IY,(IX+-9)
	LD	A,(IY+2)
	CP	A,(IX+-6)
	JR	NZ,L_67
;  148	                game->matrix[i][j].number = game->matrix[i][j].old_number;
.LINE 148

	LD	IY,(IX+-9)
	LD	A,(IY+1)
	LD	(IY+0),A
;  149	            }
;  150	        }
L_67:
.LINE 150

	INC	(IX+-5)
L_68:
	LD	A,(IX+-5)
	LD	IY,(IX+6)
	CP	A,(IY+1)
	JR	C,L_66
	INC	(IX+-4)
;  151	    }
L_71:
.LINE 151

	LD	A,(IX+-4)
	LD	IY,(IX+6)
	CP	A,(IY+0)
	JR	C,L_69
;  152	    printMap(game);
.LINE 152

	LD	BC,(IX+6)
	PUSH	BC
	CALL	_printMap
	POP	BC
;  153	}
L_74:
.LINE 153

	LD	SP,IX
	POP	IX
	RET	


;**************************** _undo ***************************
;Name                         Addr/Register   Size   Type
;_printMap                           IMPORT  -----   function
;G_8                                  IX-15      3   variable
;G_7                                  IX-12      3   variable
;G_9                                   IX-9      3   variable
;id                                    IX-6      1   variable
;j                                     IX-5      1   variable
;i                                     IX-4      1   variable
;game                                  IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "undo",153,"_undo"
;  154	
;  155	void kbArrowPlace(t_game *game) {
_kbArrowPlace:
.DEFINE "_kbArrowPlace"

.VALUE _kbArrowPlace

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "kbArrowPlace",155,"_kbArrowPlace"

.LINE 155

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

.DEFINE "key"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  156	    kb_key_t key = kb_Data[7];
.LINE 156

	LD	A,(16056350)
	LD	(IX+-4),A
;  157	
;  158	    if (game->matrix[game->cursor.pos.x][game->cursor.pos.y].number <= 0) { return; }
.LINE 158

	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(IX+-3),HL
	LD	IY,(IX+-3)
	LD	BC,(IY+0)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	IY,(IX+-3)
	LD	BC,(IY+2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	XOR	A,A
	LD	IY,HL
	CP	A,(IY+0)
	JP	P,L_84
;  159	
;  160	    if (key & kb_Down)
.LINE 160

	LD	A,(IX+-4)
	AND	A,1
	JR	Z,L_79
;  161	        placement(game, DOWN);
.LINE 161

	LD	BC,1
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_placement
	POP	BC
	POP	BC
	POP	BC
L_79:
;  162	    if (key & kb_Up)
.LINE 162

	LD	A,(IX+-4)
	AND	A,8
	JR	Z,L_81
;  163	        placement(game, UP);
.LINE 163

	LD	BC,16777215
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_placement
	POP	BC
	POP	BC
	POP	BC
L_81:
;  164	    if (key & kb_Left)
.LINE 164

	LD	A,(IX+-4)
	AND	A,2
	JR	Z,L_83
;  165	        placement(game, LEFT);
.LINE 165

	LD	BC,0
	PUSH	BC
	LD	BC,16777215
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_placement
	POP	BC
	POP	BC
	POP	BC
L_83:
;  166	    if (key & kb_Right)
.LINE 166

	LD	A,(IX+-4)
	AND	A,4
	JR	Z,L_84
;  167	        placement(game, RIGHT);
.LINE 167

	LD	BC,0
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_placement
	POP	BC
	POP	BC
	POP	BC
;  168	}
L_84:
.LINE 168

	LD	SP,IX
	POP	IX
	RET	


;**************************** _kbArrowPlace ***************************
;Name                         Addr/Register   Size   Type
;key                                   IX-4      1   variable
;game                                  IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "kbArrowPlace",168,"_kbArrowPlace"
;  169	
;  170	void kbAction(t_game *game) {
_kbAction:
.DEFINE "_kbAction"

.VALUE _kbAction

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "kbAction",170,"_kbAction"

.LINE 170

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
;  171	    if (kb_Data[6] & kb_Enter && game->matrix[game->cursor.pos.x][game->cursor.pos.y].number > CASE_EMPTY) {
.LINE 171

	LD	A,(16056348)
	AND	A,1
	JR	Z,L_93
	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	IY,(IX+-6)
	LD	BC,(IY+0)
	CALL	__stoi
	LD	A,60
	CALL	__imul_b
	LD	BC,HL
	LD	IY,(IX+6)
	LEA	HL,IY+2
	ADD	HL,BC
	LD	DE,HL
	LD	IY,(IX+-6)
	LD	BC,(IY+2)
	CALL	__stoi
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,DE
	XOR	A,A
	LD	IY,HL
	CP	A,(IY+0)
	JP	P,L_93
;  172	        eraseCursor(game);
.LINE 172

	LD	BC,(IX+6)
	PUSH	BC
	CALL	_eraseCursor
	POP	BC
;  173	        game->cursor.state = !(game->cursor.state);
.LINE 173

	LD	BC,1809
	LD	IY,(IX+6)
	CALL	__bldiy
	OR	A,A
	JR	NZ,L_87
	LD	BC,1
	LD	(IX+-3),BC
	JR	L_88
L_87:
	LD	BC,0
	LD	(IX+-3),BC
L_88:
	LD	A,(IX+-3)
	LD	BC,1809
	LD	IY,(IX+6)
	CALL	__bstiy
;  174	        printCursor(game->cursor);
.LINE 174

	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,5
	LDIR	
	CALL	_printCursor
	POP	BC
	POP	BC
;  175	        delay(WAITING_DELAY);
.LINE 175

	LD	BC,250
	PUSH	BC
	CALL	_delay
	POP	BC
;  176	    }
L_93:
.LINE 176

;  177	    if (game->cursor.state) {
.LINE 177

	LD	BC,1809
	LD	IY,(IX+6)
	CALL	__bldiy
	OR	A,A
	JR	Z,L_92
;  178	        kbArrowPlace(game);
.LINE 178

	LD	DE,(IX+6)
	PUSH	DE
	LD	(IX+-9),BC
	CALL	_kbArrowPlace
	LD	BC,(IX+-9)
	POP	DE
;  179	    } else {
.LINE 179

	JR	L_95
L_92:
;  180	        kbArrowMove(game);
.LINE 180

	LD	DE,(IX+6)
	PUSH	DE
	LD	(IX+-9),BC
	CALL	_kbArrowMove
	LD	BC,(IX+-9)
	POP	DE
;  181	    }
L_95:
.LINE 181

;  182	    if (kb_Data[6] & kb_Clear) {
.LINE 182

	LD	A,(16056348)
	AND	A,64
	JR	Z,L_97
;  183	        undo(game);
.LINE 183

	LD	DE,(IX+6)
	PUSH	DE
	LD	(IX+-9),BC
	CALL	_undo
	LD	BC,(IX+-9)
	POP	DE
;  184	    }
L_97:
.LINE 184

;  185	    if (kb_Data[1] & kb_2nd) {
.LINE 185

	LD	A,(16056338)
	AND	A,32
	JR	Z,L_98
;  186	        eraseCursor(game);
.LINE 186

	LD	DE,(IX+6)
	PUSH	DE
	LD	(IX+-9),BC
	CALL	_eraseCursor
	LD	BC,(IX+-9)
	POP	DE
;  187	        initCursor(game);
.LINE 187

	LD	DE,(IX+6)
	PUSH	DE
	LD	(IX+-9),BC
	CALL	_initCursor
	LD	BC,(IX+-9)
	POP	DE
;  188	        printCursor(game->cursor);
.LINE 188

	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LD	HL,1805
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,5
	LDIR	
	CALL	_printCursor
	POP	BC
	POP	BC
;  189	    }
;  190	}
L_98:
.LINE 190

	LD	SP,IX
	POP	IX
	RET	


;**************************** _kbAction ***************************
;Name                         Addr/Register   Size   Type
;_delay                              IMPORT  -----   function
;_printCursor                        IMPORT  -----   function
;_eraseCursor                        IMPORT  -----   function
;temp89                                IX-3      3   variable
;game                                  IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "kbAction",190,"_kbAction"
;  191	
;  192	void play(t_game game) {
_play:
.DEFINE "_play"

.VALUE _play

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "play",192,"_play"

.LINE 192

.DEFINE "game"

.CLASS 65

.VALUE 6

.TAG "s_game"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  193	    t_cursor cursor;
;  194	
;  195	    initCursor(&game);
.LINE 195

	PEA	IX+6
	CALL	_initCursor
	POP	BC
;  196	    kb_Scan();
.LINE 196

	CALL	_kb_Scan
;  197	
;  198	    printMap(&game);
.LINE 198

	PEA	IX+6
	CALL	_printMap
	POP	BC
;  199	
;  200	    while (!(game.win) && !(kb_Data[1] & kb_Del)) {
.LINE 200

	JR	L_100
L_101:
;  201	        kbAction(&game);
.LINE 201

	PEA	IX+6
	CALL	_kbAction
	POP	BC
;  202	        kb_Scan();
.LINE 202

	CALL	_kb_Scan
;  203	    }
L_100:
.LINE 203

	LD	BC,1810
	CALL	__bldix
	OR	A,A
	JR	NZ,L_102
	LD	A,(16056338)
	AND	A,128
	JR	Z,L_101
L_102:
.LINE 204

	LD	SP,IX
	POP	IX
	RET	


;**************************** _play ***************************
;Name                         Addr/Register   Size   Type
;_printMap                           IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;game                                  IX+6   1810   parameter


; Stack Frame Size: 1818 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "play",204,"_play"
	XREF _printCase:ROM
	XREF _printMap:ROM
	XREF _eraseCursor:ROM
	XREF _printCursor:ROM
	XREF _delay:ROM
	XREF _kb_Scan:ROM
	XREF __irems:ROM
	XREF __stoi:ROM
	XREF __bldix:ROM
	XREF __bldiy:ROM
	XREF __bstiy:ROM
	XREF __sldiy:ROM
	XREF __sstiy:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __imul_b:ROM
	XDEF _play
	XDEF _kbAction
	XDEF _kbArrowPlace
	XDEF _undo
	XDEF _placement
	XDEF _checkPlacement
	XDEF _isInMap
	XDEF _checkGameWin
	XDEF _kbArrowMove
	XDEF _moveCursor
	XDEF _cursorCanMove
	XDEF _initCursor
	XDEF _setFirstNumber
	END
