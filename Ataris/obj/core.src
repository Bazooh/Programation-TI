; Zilog eZ80 ANSI C Compiler Release 3.4
; -debug -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\CORE.C"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",9
.DEFINE "sign"
.VALUE 0
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "mant"
.VALUE 2
.CLASS 8
.DIM 7
.TYPE 108
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",18
.DEFINE "real"
.VALUE 0
.CLASS 8
.TAG "NONAME3"
.TYPE 8
.ENDEF
.DEFINE "imag"
.VALUE 9
.CLASS 8
.TAG "NONAME3"
.TYPE 8
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",11
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME3"
.TYPE 104
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",20
.DEFINE "dim"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME4"
.TYPE 104
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",11
.DEFINE "cols"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rows"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "items"
.VALUE 2
.CLASS 8
.DIM 1
.TAG "NONAME3"
.TYPE 104
.ENDEF
.ENDREC "NONAME7"
.BEGREC "NONAME8",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",3
.DEFINE "len"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 98
.ENDEF
.ENDREC "NONAME9"
.BEGREC "NONAME10",3
.DEFINE "size"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME10"
.BEGREC "font",12
.DEFINE "font"
.VALUE 0
.CLASS 8
.TAG "font"
.TYPE 40
.ENDEF
.DEFINE "drawChar"
.VALUE 3
.CLASS 8
.TYPE 545
.ENDEF
.DEFINE "getWidth"
.VALUE 6
.CLASS 8
.TYPE 558
.ENDEF
.DEFINE "getHeight"
.VALUE 9
.CLASS 8
.TYPE 558
.ENDEF
.ENDREC "font"
.BEGREC "__stdio_file",1
.DEFINE "slot"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "__stdio_file"
.BEGREC "s_pos",4
.DEFINE "x"
.VALUE 0
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "y"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "s_pos"
.BEGREC "s_precision_pos",8
.DEFINE "x"
.VALUE 0
.CLASS 8
.TYPE 6
.ENDEF
.DEFINE "y"
.VALUE 4
.CLASS 8
.TYPE 6
.ENDEF
.ENDREC "s_precision_pos"
.BEGREC "s_ball",20
.DEFINE "pos"
.VALUE 0
.CLASS 8
.TAG "s_precision_pos"
.TYPE 8
.ENDEF
.DEFINE "old_pos"
.VALUE 8
.CLASS 8
.TAG "s_pos"
.TYPE 8
.ENDEF
.DEFINE "direction"
.VALUE 12
.CLASS 8
.TYPE 6
.ENDEF
.DEFINE "speed"
.VALUE 16
.CLASS 8
.TYPE 6
.ENDEF
.ENDREC "s_ball"
.BEGREC "NONAME11",3
.DEFINE "width"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME11"
.BEGREC "NONAME12",3
.DEFINE "width"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "data"
.VALUE 2
.CLASS 8
.DIM 1
.TYPE 108
.ENDEF
.ENDREC "NONAME12"
.BEGREC "NONAME13",6
.DEFINE "x"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "y"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME13"
.BEGREC "NONAME14",12
.DEFINE "xmin"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ymin"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "xmax"
.VALUE 6
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ymax"
.VALUE 9
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME14"
.BEGREC "NONAME15",18
.DEFINE "map"
.VALUE 0
.CLASS 8
.TYPE 44
.ENDEF
.DEFINE "tiles"
.VALUE 3
.CLASS 8
.TAG "NONAME11"
.TYPE 296
.ENDEF
.DEFINE "tile_height"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "tile_width"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "draw_height"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "draw_width"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "type_width"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "type_height"
.VALUE 11
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "height"
.VALUE 12
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "width"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "y_loc"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "x_loc"
.VALUE 15
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME15"
.BEGREC "s_obstacle",35
.DEFINE "point"
.VALUE 0
.CLASS 8
.DIM 4
.TAG "s_pos"
.TYPE 104
.ENDEF
.DEFINE "ortho"
.VALUE 16
.CLASS 8
.DIM 4
.TYPE 108
.ENDEF
.DEFINE "id"
.VALUE 20
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "life"
.VALUE 21
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "hide"
.VALUE 23
.CLASS 8
.DIM 4
.TYPE 108
.ENDEF
.DEFINE "in_matrix"
.VALUE 27
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "matrix"
.VALUE 28
.CLASS 8
.TAG "s_pos"
.TYPE 8
.ENDEF
.DEFINE "next"
.VALUE 32
.CLASS 8
.TAG "s_obstacle"
.TYPE 40
.ENDEF
.ENDREC "s_obstacle"
.BEGREC "s_game_info",3
.DEFINE "ob_contact"
.VALUE 0
.CLASS 8
.TAG "s_obstacle"
.TYPE 40
.ENDEF
.ENDREC "s_game_info"
;    1	
;    2	#include "core.h"
;    3	
;    4	double rad(int16_t angle) {
_rad:
.DEFINE "_rad"

.VALUE _rad

.CLASS 2

.TYPE 70

.ENDEF

.BEGFUNC "rad",4,"_rad"

.LINE 4

.DEFINE "angle"

.CLASS 65

.VALUE 6

.TYPE 3

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;    5	    return (double)(angle * M_PI / 180);
.LINE 5

	LD	A,(IX+7)
	RLA	
	SBC	A,A
	LD	BC,(IX+6)
	CALL	__stoi
	LD	BC,HL
	CALL	__ltof
	LD	HL,4788187
	LD	E,64
	CALL	__fmul
	LD	HL,3407872
	LD	E,67
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
;    6	}
.LINE 6

	LD	SP,IX
	POP	IX
	RET	


;**************************** _rad ***************************
;Name                         Addr/Register   Size   Type
;angle                                 IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "rad",6,"_rad"
;    7	
;    8	int16_t deg(double angle) {
_deg:
.DEFINE "_deg"

.VALUE _deg

.CLASS 2

.TYPE 67

.ENDEF

.BEGFUNC "deg",8,"_deg"

.LINE 8

.DEFINE "angle"

.CLASS 65

.VALUE 6

.TYPE 6

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;    9	    return (int16_t)(angle * 180 / M_PI);
.LINE 9

	LD	HL,3407872
	LD	E,67
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fmul
	LD	HL,4788187
	LD	E,64
	CALL	__fdiv
	CALL	__ftol
	LD	HL,BC
;   10	}
.LINE 10

	LD	SP,IX
	POP	IX
	RET	


;**************************** _deg ***************************
;Name                         Addr/Register   Size   Type
;angle                                 IX+6      4   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "deg",10,"_deg"
;   11	
;   12	double primaryMeasure(double angle) {
_primaryMeasure:
.DEFINE "_primaryMeasure"

.VALUE _primaryMeasure

.CLASS 2

.TYPE 70

.ENDEF

.BEGFUNC "primaryMeasure",12,"_primaryMeasure"

.LINE 12

.DEFINE "angle"

.CLASS 65

.VALUE 6

.TYPE 6

.ENDEF

.DEFINE "angle_deg"

.CLASS 65

.VALUE -2

.TYPE 3

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   13	    int16_t angle_deg;
;   14	
;   15	    angle_deg = deg(angle);
.LINE 15

	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_deg
	POP	BC
	POP	BC
	LD	(IX+-2),L
	LD	(IX+-1),H
;   16	    angle_deg %= 360;
.LINE 16

	LD	BC,(IX+-2)
	CALL	__stoi
	LD	BC,360
	CALL	__irems
	LD	(IX+-2),L
	LD	(IX+-1),H
;   17	    if (angle_deg < 0) { angle_deg += 360; }
.LINE 17

	LD	HL,(IX+-2)
	CALL	__scmpzero
	CALL	__setflag
	JP	P,L_3
	LD	HL,(IX+-2)
	LD.LIS	DE,360
	ADD.SIS	HL,DE
	LD	(IX+-2),L
	LD	(IX+-1),H
L_3:
;   18	
;   19	    return rad(angle_deg);
.LINE 19

	LD	BC,(IX+-2)
	PUSH	BC
	CALL	_rad
	POP	BC
;   20	}
.LINE 20

	LD	SP,IX
	POP	IX
	RET	


;**************************** _primaryMeasure ***************************
;Name                         Addr/Register   Size   Type
;_rad                                IMPORT  -----   function
;_deg                                IMPORT  -----   function
;angle_deg                             IX-2      2   variable
;angle                                 IX+6      4   parameter


; Stack Frame Size: 14 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "primaryMeasure",20,"_primaryMeasure"
;   21	
;   22	uint8_t calculateContact(t_precision_pos *contact_point, t_precision_pos point_a, double a, double b, double c, double d) {
_calculateContact:
.DEFINE "_calculateContact"

.VALUE _calculateContact

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "calculateContact",22,"_calculateContact"

.LINE 22

.DEFINE "contact_point"

.CLASS 65

.VALUE 6

.TAG "s_precision_pos"

.TYPE 40

.ENDEF

.DEFINE "point_a"

.CLASS 65

.VALUE 9

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE 18

.TYPE 6

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 24

.TYPE 6

.ENDEF

.DEFINE "c"

.CLASS 65

.VALUE 30

.TYPE 6

.ENDEF

.DEFINE "d"

.CLASS 65

.VALUE 36

.TYPE 6

.ENDEF

.DEFINE "p1_is_in"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "variables"

.CLASS 65

.VALUE -35

.DIM 7

.TYPE 102

.ENDEF

.DEFINE "p2_is_in"

.CLASS 65

.VALUE -36

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-79
	LD	SP,HL
;   23	    uint8_t p1_is_in;
;   24	    uint8_t p2_is_in;
;   25	    double variables[7];
;   26	
;   27	    a_2 = a*a;
.LINE 27

	LEA	BC,IX+-23
	LD	(IX+-3),BC
	LD	HL,(IX+18)
	LD	E,(IX+21)
	LD	BC,(IX+18)
	LD	A,(IX+21)
	CALL	__fmul
	LD	IY,(IX+-3)
	LD	(IY),BC
	LD	(IY+3),A
;   28	    c_2 = c*c;
.LINE 28

	LEA	BC,IX+-19
	LD	(IX+-6),BC
	LD	HL,(IX+30)
	LD	E,(IX+33)
	LD	BC,(IX+30)
	LD	A,(IX+33)
	CALL	__fmul
	LD	IY,(IX+-6)
	LD	(IY),BC
	LD	(IY+3),A
;   29	    delta = 4*(2*a*b*c*d - a_2*d*d - c_2*b*b + BALL_RAYON*BALL_RAYON*(a_2 + c_2));
.LINE 29

	OR	A,A
	SBC	HL,HL
	LD	E,64
	LD	BC,(IX+18)
	LD	A,(IX+21)
	CALL	__fmul
	LD	HL,(IX+24)
	LD	E,(IX+27)
	CALL	__fmul
	LD	HL,(IX+30)
	LD	E,(IX+33)
	CALL	__fmul
	LD	HL,(IX+36)
	LD	E,(IX+39)
	CALL	__fmul
	LD	(IX+-70),BC
	LD	(IX+-71),A
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+24)
	LD	A,(IX+27)
	CALL	__fmul
	LD	HL,(IX+24)
	LD	E,(IX+27)
	CALL	__fmul
	LD	(IX+-74),BC
	LD	(IX+-75),A
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+36)
	LD	A,(IX+39)
	CALL	__fmul
	LD	HL,(IX+36)
	LD	E,(IX+39)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-75)
	LD	BC,(IX+-74)
	CALL	__fadd
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-71)
	LD	BC,(IX+-70)
	CALL	__fsub
	LD	(IX+-78),BC
	LD	(IX+-79),A
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+-3)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	HL,1048576
	LD	E,65
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-79)
	LD	BC,(IX+-78)
	CALL	__fadd
	LD	HL,8388608
	LD	E,64
	CALL	__fmul
	LEA	IY,IX+-35
	LD	(IY+20),BC
	LD	(IY+23),A
;   30	
;   31	    if (delta < 0) { return FALSE; }
.LINE 31

	LD	HL,(IY+20)
	LD	E,(IY+23)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_6
	XOR	A,A
	JR	L_22
L_6:
;   32	
;   33	    sqrt_delta = sqrt(delta);
.LINE 33

	LEA	IY,IX+-35
	LEA	BC,IY+24
	LD	(IX+-45),BC
	LD	BC,(IY+20)
	LD	A,(IY+23)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_sqrt
	POP	BC
	POP	BC
	LD	IY,(IX+-45)
	LD	(IY),HL
	LD	(IY+3),E
;   34	    t1 = (-2*(a*b + c*d) - sqrt_delta) / (2*(a_2 + c_2));
.LINE 34

	LD	HL,(IX+24)
	LD	E,(IX+27)
	LD	BC,(IX+18)
	LD	A,(IX+21)
	CALL	__fmul
	LD	(IX+-58),BC
	LD	(IX+-55),A
	LD	HL,(IX+36)
	LD	E,(IX+39)
	LD	BC,(IX+30)
	LD	A,(IX+33)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-55)
	LD	BC,(IX+-58)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,192
	CALL	__fmul
	LD	(IX+-54),BC
	LD	(IX+-59),A
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+-54)
	CALL	__fsub
	LD	(IX+-62),BC
	LD	(IX+-63),A
	LEA	IY,IX+-35
	LEA	BC,IY+12
	LD	HL,(IY+16)
	LD	E,(IY+19)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-63)
	LD	BC,(IX+-62)
	CALL	__fdiv
	LD	(IX+-35),BC
	LD	(IX+-32),A
;   35	    t2 = (-2*(a*b + c*d) + sqrt_delta) / (2*(a_2 + c_2));
.LINE 35

	LD	IY,(IX+-45)
	LD	E,(IX+-59)
	LD	HL,(IX+-54)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IX+-66),BC
	LD	(IX+-67),A
	LEA	IY,IX+-35
	LEA	BC,IY+12
	LD	HL,(IY+16)
	LD	E,(IY+19)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-67)
	LD	BC,(IX+-66)
	CALL	__fdiv
	LEA	IY,IX+-35
	LD	(IY+4),BC
	LD	(IY+7),A
;   36	
;   37	    p1_is_in = FALSE;
.LINE 37

	LD	(IX+-7),0
;   38	    p2_is_in = FALSE;
.LINE 38

	LD	(IX+-36),0
;   39	    if (t1 >= 0 && t1 <= 1) {
.LINE 39

	LD	HL,(IX+-35)
	LD	E,(IX+-32)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_11
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-35)
	LD	A,(IX+-32)
	CALL	__fcmp
	JP	M,L_11
;   40	        p1_is_in = TRUE;
.LINE 40

	LD	(IX+-7),1
;   41	    }
L_11:
.LINE 41

;   42	    if (t2 >= 0 && t2 <= 1) {
.LINE 42

	LEA	IY,IX+-35
	LEA	BC,IY+4
	LD	(IX+-39),BC
	LEA	BC,IY+4
	LD	(IX+-42),BC
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_14
	LEA	IY,IX+-35
	LEA	BC,IY+4
	LD	(IX+-39),BC
	LEA	BC,IY+4
	LD	(IX+-42),BC
	LD	HL,8388608
	LD	E,63
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fcmp
	JP	M,L_14
;   43	        p2_is_in = TRUE;
.LINE 43

	LD	(IX+-36),1
;   44	    }
L_14:
.LINE 44

;   45	
;   46	    if (!(p1_is_in || p2_is_in)) { return FALSE; }
.LINE 46

	LD	A,(IX+-7)
	OR	A,A
	JR	NZ,L_20
	LD	A,(IX+-36)
	OR	A,A
	JR	NZ,L_20
	XOR	A,A
	JR	L_22
L_20:
;   47	
;   48	    if (p1_is_in && p2_is_in) {
.LINE 48

	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_19
	LD	A,(IX+-36)
	OR	A,A
	JR	Z,L_19
;   49	        moy_t = (t1 + t2) / 2;
.LINE 49

	LEA	BC,IX+-27
	LD	(IX+-48),BC
	LD	IY,(IX+-39)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+-35)
	LD	A,(IX+-32)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	IY,(IX+-48)
	LD	(IY),BC
	LD	(IY+3),A
;   50	        contact_point->x = a*moy_t + point_a.x;
.LINE 50

	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+18)
	LD	A,(IX+21)
	CALL	__fmul
	LD	HL,(IX+9)
	LD	E,(IX+12)
	CALL	__fadd
	LD	IY,(IX+6)
	LD	(IY+0),BC
	LD	(IY+3),A
;   51	        contact_point->y = c*moy_t + point_a.y;
.LINE 51

	LD	IY,(IX+-48)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+30)
	LD	A,(IX+33)
	CALL	__fmul
	LD	HL,(IX+13)
	LD	E,(IX+16)
	CALL	__fadd
	LD	IY,(IX+6)
	LD	(IY+4),BC
	LD	(IY+7),A
;   52	    } else if (p1_is_in) {
.LINE 52

	JR	L_21
L_19:
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_17
;   53	        contact_point->x = a*t1 + point_a.x;
.LINE 53

	LD	HL,(IX+18)
	LD	E,(IX+21)
	LD	BC,(IX+-35)
	LD	A,(IX+-32)
	CALL	__fmul
	LD	HL,(IX+9)
	LD	E,(IX+12)
	CALL	__fadd
	LD	IY,(IX+6)
	LD	(IY+0),BC
	LD	(IY+3),A
;   54	        contact_point->y = c*t1 + point_a.y;
.LINE 54

	LD	HL,(IX+30)
	LD	E,(IX+33)
	LD	BC,(IX+-35)
	LD	A,(IX+-32)
	CALL	__fmul
	LD	HL,(IX+13)
	LD	E,(IX+16)
	CALL	__fadd
	LD	(IY+4),BC
	LD	(IY+7),A
;   55	    } else {
.LINE 55

	JR	L_21
L_17:
;   56	        contact_point->x = a*t2 + point_a.x;
.LINE 56

	LD	BC,(IX+-42)
	LD	(IX+-51),BC
	LD	IY,(IX+-51)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+18)
	LD	A,(IX+21)
	CALL	__fmul
	LD	HL,(IX+9)
	LD	E,(IX+12)
	CALL	__fadd
	LD	IY,(IX+6)
	LD	(IY+0),BC
	LD	(IY+3),A
;   57	        contact_point->y = c*t2 + point_a.y;
.LINE 57

	LD	IY,(IX+-51)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IX+30)
	LD	A,(IX+33)
	CALL	__fmul
	LD	HL,(IX+13)
	LD	E,(IX+16)
	CALL	__fadd
	LD	IY,(IX+6)
	LD	(IY+4),BC
	LD	(IY+7),A
;   58	    }
L_21:
.LINE 58

;   59	    return TRUE;
.LINE 59

	LD	A,1
;   60	}
L_22:
.LINE 60

	LD	SP,IX
	POP	IX
	RET	


;**************************** _calculateContact ***************************
;Name                         Addr/Register   Size   Type
;_sqrt                               IMPORT  -----   function
;G_6                                  IX-42      3   variable
;G_5                                  IX-39      3   variable
;p2_is_in                             IX-36      1   variable
;variables                            IX-35     28   variable
;p1_is_in                              IX-7      1   variable
;d                                    IX+36      4   parameter
;c                                    IX+30      4   parameter
;b                                    IX+24      4   parameter
;a                                    IX+18      4   parameter
;point_a                               IX+9      8   parameter
;contact_point                         IX+6      3   parameter


; Stack Frame Size: 121 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "calculateContact",60,"_calculateContact"
;   61	
;   62	void setContactPoint(t_precision_pos *contact_points, t_precision_pos *contact_point, uint8_t *contact) {
_setContactPoint:
.DEFINE "_setContactPoint"

.VALUE _setContactPoint

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setContactPoint",62,"_setContactPoint"

.LINE 62

.DEFINE "contact_points"

.CLASS 65

.VALUE 6

.TAG "s_precision_pos"

.TYPE 40

.ENDEF

.DEFINE "contact_point"

.CLASS 65

.VALUE 9

.TAG "s_precision_pos"

.TYPE 40

.ENDEF

.DEFINE "contact"

.CLASS 65

.VALUE 12

.TYPE 44

.ENDEF

.DEFINE "nb_contact"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   63	    uint8_t i;
;   64	    uint8_t nb_contact;
;   65	
;   66	    nb_contact = 0;
.LINE 66

	LD	(IX+-1),0
;   67	
;   68	    while (contact[nb_contact]) { nb_contact++; }
.LINE 68

	JR	L_24
L_25:
	INC	(IX+-1)
L_24:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+12)
	ADD	HL,BC
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_25
;   69	
;   70	    contact_point->x = 0;
.LINE 70

	LD	BC,0
	LD	IY,(IX+9)
	LD	(IY+0),BC
	LD	(IY+3),0
;   71	    contact_point->y = 0;
.LINE 71

	LD	(IY+4),BC
	LD	(IY+7),0
;   72	    for (i = 0; i < nb_contact; ++i) {
.LINE 72

	LD	(IX+-2),0
	JR	L_29
L_27:
;   73	        contact_point->x += contact_points[contact[i] - 1].x;
.LINE 73

	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+12)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	DEC	HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	LD	IY,(IX+9)
	LD	HL,(IY+0)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+9)
	LD	(IY+0),BC
	LD	(IY+3),A
;   74	        contact_point->y += contact_points[contact[i] - 1].y;
.LINE 74

	LD	A,(IX+-2)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+12)
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	DEC	HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	IY,BC
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fadd
	LD	IY,(IX+9)
	LD	(IY+4),BC
	LD	(IY+7),A
	INC	(IX+-2)
;   75	    }
L_29:
.LINE 75

	LD	A,(IX+-2)
	CP	A,(IX+-1)
	JR	C,L_27
;   76	    contact_point->x /= nb_contact;
.LINE 76

	UEXT	HL
	LD	L,(IX+-1)
	LD	A,H
	LD	BC,HL
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+9)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fdiv
	LD	(IY+0),BC
	LD	(IY+3),A
;   77	    contact_point->y /= nb_contact;
.LINE 77

	UEXT	HL
	LD	L,(IX+-1)
	LD	A,H
	LD	BC,HL
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fdiv
	LD	(IY+4),BC
	LD	(IY+7),A
;   78	}
.LINE 78

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setContactPoint ***************************
;Name                         Addr/Register   Size   Type
;i                                     IX-2      1   variable
;nb_contact                            IX-1      1   variable
;contact                              IX+12      3   parameter
;contact_point                         IX+9      3   parameter
;contact_points                        IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setContactPoint",78,"_setContactPoint"
;   79	
;   80	void resetContact(uint8_t *contact) {
_resetContact:
.DEFINE "_resetContact"

.VALUE _resetContact

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "resetContact",80,"_resetContact"

.LINE 80

.DEFINE "contact"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;   81	    uint8_t i;
;   82	    for (i = 0; i < NUMBER_POINT_OBSTACLE; ++i) {
.LINE 82

	LD	(IX+-1),0
	JR	L_34
L_32:
;   83	        contact[i] = 0;
.LINE 83

	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(HL),0
	INC	(IX+-1)
;   84	    }
L_34:
.LINE 84

	LD	A,(IX+-1)
	CP	A,4
	JR	C,L_32
;   85	}
.LINE 85

	LD	SP,IX
	POP	IX
	RET	


;**************************** _resetContact ***************************
;Name                         Addr/Register   Size   Type
;i                                     IX-1      1   variable
;contact                               IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "resetContact",85,"_resetContact"
;   86	
;   87	uint8_t ballDirection(t_ball ball) {
_ballDirection:
.DEFINE "_ballDirection"

.VALUE _ballDirection

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "ballDirection",87,"_ballDirection"

.LINE 87

.DEFINE "ball"

.CLASS 65

.VALUE 6

.TAG "s_ball"

.TYPE 8

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   88	    uint8_t i;
;   89	
;   90	    for (i = 0; i < NUMBER_DIRECTION - 1; ++i) {
.LINE 90

	LD	(IX+-1),0
	JR	L_40
L_38:
;   91	        if (ball.direction >= DIRECTION[i][0] && ball.direction < DIRECTION[i][1]) { return i; }
.LINE 91

	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,_DIRECTION
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	IY,(IX+-4)
	LD	HL,(IX+18)
	LD	E,(IX+21)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fcmp
	JP	M,L_39
	LD	IY,(IX+-4)
	LD	HL,(IX+18)
	LD	E,(IX+21)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fcmp
	JP	P,L_39
	LD	A,(IX+-1)
	JR	L_42
;   92	    }
L_39:
.LINE 92

	INC	(IX+-1)
L_40:
	LD	A,(IX+-1)
	CP	A,3
	JR	C,L_38
;   93	    return NUMBER_DIRECTION - 1;
.LINE 93

	LD	A,3
;   94	}
L_42:
.LINE 94

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ballDirection ***************************
;Name                         Addr/Register   Size   Type
;_DIRECTION                          IMPORT     32   variable
;G_7                                   IX-4      3   variable
;i                                     IX-1      1   variable
;ball                                  IX+6     20   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "ballDirection",94,"_ballDirection"
;   95	
;   96	uint8_t hurtObstacle(uint8_t matrix[MATRIX_X_LENGTH][MATRIX_Y_LENGTH], t_obstacle *obstacles, t_obstacle *obstacle) {
_hurtObstacle:
.DEFINE "_hurtObstacle"

.VALUE _hurtObstacle

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "hurtObstacle",96,"_hurtObstacle"

.LINE 96

.DEFINE "matrix"

.CLASS 65

.VALUE 6

.DIM 5

.TYPE 812

.ENDEF

.DEFINE "obstacles"

.CLASS 65

.VALUE 9

.TAG "s_obstacle"

.TYPE 40

.ENDEF

.DEFINE "obstacle"

.CLASS 65

.VALUE 12

.TAG "s_obstacle"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;   97	    if (obstacle->id) {
.LINE 97

	LD	IY,(IX+12)
	LD	A,(IY+20)
	OR	A,A
	JR	Z,L_47
;   98	        --obstacle->life;
.LINE 98

	LD	IY,(IX+12)
	LD	IY,(IY+21)
	LEA	BC,IY+-1
	LD	IY,(IX+12)
	LD	(IY+21),C
	LD	(IY+22),B
;   99	        if (!obstacle->life) {
.LINE 99

	LD	HL,(IY+21)
	CALL	__scmpzero
	JR	NZ,L_47
;  100	            if (obstacle->in_matrix) {
.LINE 100

	LD	IY,(IX+12)
	LD	A,(IY+27)
	OR	A,A
	JR	Z,L_44
;  101	                setAdjHiddenObstacle(matrix, obstacles, obstacle->matrix.x, obstacle->matrix.y, FALSE);
.LINE 101

	LD	IY,(IX+12)
	LEA	BC,IY+28
	LD	(IX+-3),BC
	LD	BC,0
	PUSH	BC
	LD	IY,(IX+-3)
	LD	C,(IY+3)
	LD	B,0
	PUSH	BC
	LD	C,(IY+0)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_setAdjHiddenObstacle
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  102	                matrix[obstacle->matrix.x][obstacle->matrix.y] = 0;
.LINE 102

	LD	IY,(IX+12)
	LEA	BC,IY+28
	LD	(IX+-6),BC
	LD	IY,(IX+-6)
	LD	HL,(IY+0)
	LD	A,5
	CALL	__imul_b
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(IY+3)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	(HL),0
;  103	            }
L_44:
.LINE 103

;  104	            eraseObstacle(obstacle);
.LINE 104

	LD	BC,(IX+12)
	PUSH	BC
	CALL	_eraseObstacle
	POP	BC
;  105	            removeObstacle(obstacles, obstacle->id);
.LINE 105

	LD	IY,(IX+12)
	LD	C,(IY+20)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	CALL	_removeObstacle
	POP	BC
	POP	BC
;  106	            return TRUE;
.LINE 106

	LD	A,1
	JR	L_48
;  107	        }
;  108	    }
L_47:
.LINE 108

;  109	    return FALSE;
.LINE 109

	XOR	A,A
;  110	}
L_48:
.LINE 110

	LD	SP,IX
	POP	IX
	RET	


;**************************** _hurtObstacle ***************************
;Name                         Addr/Register   Size   Type
;_removeObstacle                     IMPORT  -----   function
;_eraseObstacle                      IMPORT  -----   function
;_setAdjHiddenObstacle               IMPORT  -----   function
;obstacle                             IX+12      3   parameter
;obstacles                             IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "hurtObstacle",110,"_hurtObstacle"
;  111	
;  112	uint8_t checkDirection(t_ball ball, uint8_t direction, t_precision_pos a, t_precision_pos b) {
_checkDirection:
.DEFINE "_checkDirection"

.VALUE _checkDirection

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "checkDirection",112,"_checkDirection"

.LINE 112

.DEFINE "ball"

.CLASS 65

.VALUE 6

.TAG "s_ball"

.TYPE 8

.ENDEF

.DEFINE "direction"

.CLASS 65

.VALUE 27

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE 30

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 39

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-24
	LD	SP,HL
;  113	    switch (direction) {
.LINE 113

	LD	A,(IX+27)
	UEXT	HL
	LD	L,A
	CALL	__seqcaseD
	JP	(HL)
L__28:
	DW	4
	DW	0
	DB	0
	DW24	L_49	

	DW24	L_55	

	DW24	L_61	

	DW24	L_67	

	DW24	L_73	

;  114	        case 0:
L_49:
.LINE 114

;  115	            if ((ball.pos.x > a.x && ball.pos.x > b.x) || (ball.pos.y < a.y && ball.pos.y < b.y)) { return FALSE; }
.LINE 115

	LEA	BC,IX+6
	LD	(IX+-3),BC
	LD	HL,(IX+30)
	LD	E,(IX+33)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	P,L_52
	LEA	BC,IX+6
	LD	(IX+-3),BC
	LD	HL,(IX+39)
	LD	E,(IX+42)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	M,L_53
L_52:
	LD	BC,(IX+-3)
	LD	(IX+-6),BC
	LD	IY,(IX+-6)
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+34)
	LD	A,(IX+37)
	CALL	__fcmp
	JP	P,L_73
	LD	IY,(IX+-6)
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+43)
	LD	A,(IX+46)
	CALL	__fcmp
	JP	P,L_73
L_53:
	XOR	A,A
	JR	L_74
;  116	            break;
.LINE 116

;  117	        case 1:
L_55:
.LINE 117

;  118	            if ((ball.pos.x < a.x && ball.pos.x < b.x) || (ball.pos.y < a.y && ball.pos.y < b.y)) { return FALSE; }
.LINE 118

	LEA	BC,IX+6
	LD	(IX+-9),BC
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,(IX+30)
	LD	A,(IX+33)
	CALL	__fcmp
	JP	P,L_58
	LEA	BC,IX+6
	LD	(IX+-9),BC
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,(IX+39)
	LD	A,(IX+42)
	CALL	__fcmp
	JP	M,L_59
L_58:
	LD	BC,(IX+-9)
	LD	(IX+-12),BC
	LD	IY,(IX+-12)
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+34)
	LD	A,(IX+37)
	CALL	__fcmp
	JP	P,L_73
	LD	IY,(IX+-12)
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+43)
	LD	A,(IX+46)
	CALL	__fcmp
	JP	P,L_73
L_59:
	XOR	A,A
	JR	L_74
;  119	            break;
.LINE 119

;  120	        case 2:
L_61:
.LINE 120

;  121	            if ((ball.pos.x < a.x && ball.pos.x < b.x) || (ball.pos.y > a.y && ball.pos.y > b.y)) { return FALSE; }
.LINE 121

	LEA	BC,IX+6
	LD	(IX+-15),BC
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,(IX+30)
	LD	A,(IX+33)
	CALL	__fcmp
	JP	P,L_64
	LEA	BC,IX+6
	LD	(IX+-15),BC
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,(IX+39)
	LD	A,(IX+42)
	CALL	__fcmp
	JP	M,L_65
L_64:
	LD	BC,(IX+-15)
	LD	(IX+-18),BC
	LD	HL,(IX+34)
	LD	E,(IX+37)
	LD	IY,(IX+-18)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fcmp
	JP	P,L_73
	LD	HL,(IX+43)
	LD	E,(IX+46)
	LD	IY,(IX+-18)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fcmp
	JP	P,L_73
L_65:
	XOR	A,A
	JR	L_74
;  122	            break;
.LINE 122

;  123	        case 3:
L_67:
.LINE 123

;  124	            if ((ball.pos.x > a.x && ball.pos.x > b.x) || (ball.pos.y > a.y && ball.pos.y > b.y)) { return FALSE; }
.LINE 124

	LEA	BC,IX+6
	LD	(IX+-21),BC
	LD	HL,(IX+30)
	LD	E,(IX+33)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	P,L_70
	LEA	BC,IX+6
	LD	(IX+-21),BC
	LD	HL,(IX+39)
	LD	E,(IX+42)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	M,L_71
L_70:
	LD	BC,(IX+-21)
	LD	(IX+-24),BC
	LD	HL,(IX+34)
	LD	E,(IX+37)
	LD	IY,(IX+-24)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fcmp
	JP	P,L_73
	LD	HL,(IX+43)
	LD	E,(IX+46)
	LD	IY,(IX+-24)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fcmp
	JP	P,L_73
L_71:
	XOR	A,A
	JR	L_74
;  125	            break;
;  126	    }
L_73:
.LINE 126

;  127	    return TRUE;
.LINE 127

	LD	A,1
;  128	}
L_74:
.LINE 128

	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkDirection ***************************
;Name                         Addr/Register   Size   Type
;G_20                                 IX-24      3   variable
;G_19                                 IX-21      3   variable
;G_17                                 IX-18      3   variable
;G_16                                 IX-15      3   variable
;G_14                                 IX-12      3   variable
;G_13                                  IX-9      3   variable
;G_11                                  IX-6      3   variable
;G_10                                  IX-3      3   variable
;b                                    IX+39      8   parameter
;a                                    IX+30      8   parameter
;direction                            IX+27      1   parameter
;ball                                  IX+6     20   parameter


; Stack Frame Size: 72 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "checkDirection",128,"_checkDirection"
;  129	
;  130	uint8_t preCheck(t_ball ball, uint8_t direction, t_precision_pos a, t_precision_pos b, uint8_t hide) {
_preCheck:
.DEFINE "_preCheck"

.VALUE _preCheck

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "preCheck",130,"_preCheck"

.LINE 130

.DEFINE "ball"

.CLASS 65

.VALUE 6

.TAG "s_ball"

.TYPE 8

.ENDEF

.DEFINE "direction"

.CLASS 65

.VALUE 27

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE 30

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 39

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "hide"

.CLASS 65

.VALUE 48

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  131	    if (hide) { return FALSE; }
.LINE 131

	LD	A,(IX+48)
	OR	A,A
	JR	Z,L_77
	XOR	A,A
	JR	L_79
L_77:
;  132	    if (!checkDirection(ball, direction, a, b)) { return FALSE; }
.LINE 132

	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+39
	LD	BC,8
	LDIR	
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+30
	LD	BC,8
	LDIR	
	LD	C,(IX+27)
	LD	B,0
	PUSH	BC
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-21
	LD	SP,IY
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+6
	LD	BC,20
	LDIR	
	CALL	_checkDirection
	LD	IY,42
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	NZ,L_78
	XOR	A,A
	JR	L_79
L_78:
;  133	    return TRUE;
.LINE 133

	LD	A,1
;  134	}
L_79:
.LINE 134

	LD	SP,IX
	POP	IX
	RET	


;**************************** _preCheck ***************************
;Name                         Addr/Register   Size   Type
;hide                                 IX+48      1   parameter
;b                                    IX+39      8   parameter
;a                                    IX+30      8   parameter
;direction                            IX+27      1   parameter
;ball                                  IX+6     20   parameter


; Stack Frame Size: 51 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "preCheck",134,"_preCheck"
;  135	
;  136	uint8_t calculateContactOrtho(t_ball ball, t_precision_pos *contact_point, uint8_t ortho, t_precision_pos a, t_precision_pos b) {
_calculateContactOrtho:
.DEFINE "_calculateContactOrtho"

.VALUE _calculateContactOrtho

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "calculateContactOrtho",136,"_calculateContactOrtho"

.LINE 136

.DEFINE "ball"

.CLASS 65

.VALUE 6

.TAG "s_ball"

.TYPE 8

.ENDEF

.DEFINE "contact_point"

.CLASS 65

.VALUE 27

.TAG "s_precision_pos"

.TYPE 40

.ENDEF

.DEFINE "ortho"

.CLASS 65

.VALUE 30

.TYPE 12

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE 33

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 42

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "t"

.CLASS 65

.VALUE -4

.TYPE 6

.ENDEF

.DEFINE "ac_y"

.CLASS 65

.VALUE -8

.TYPE 6

.ENDEF

.DEFINE "ac_x"

.CLASS 65

.VALUE -12

.TYPE 6

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-12
	LD	SP,HL
;  137	    double ac_x, ac_y, t;
;  138	
;  139	    ac_x = ball.pos.x - a.x;
.LINE 139

	LD	HL,(IX+33)
	LD	E,(IX+36)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+-12),BC
	LD	(IX+-9),A
;  140	    ac_y = ball.pos.y - a.y;
.LINE 140

	LD	HL,(IX+37)
	LD	E,(IX+40)
	LD	BC,(IX+10)
	LD	A,(IX+13)
	CALL	__fsub
	LD	(IX+-8),BC
	LD	(IX+-5),A
;  141	
;  142	    if (ortho == HORIZONTAL && abs(ac_y) <= BALL_RAYON) {
.LINE 142

	LD	A,(IX+30)
	CP	A,1
	JR	NZ,L_88
	LD	BC,(IX+-8)
	LD	A,(IX+-5)
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	LD	HL,3
	OR	A,A
	SBC	HL,BC
	JP	M,L_88
;  143	        t =  ac_x / (b.x - a.x);
.LINE 143

	LD	HL,(IX+33)
	LD	E,(IX+36)
	LD	BC,(IX+42)
	LD	A,(IX+45)
	CALL	__fsub
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-12)
	LD	A,(IX+-9)
	CALL	__fdiv
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  144	
;  145	        if (t >= 0 && t <= 1) {
.LINE 145

	LD	HL,BC
	LD	E,(IX+-1)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_89
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fcmp
	JP	M,L_89
;  146	            contact_point->x = ball.pos.x;
.LINE 146

	LD	BC,(IX+6)
	LD	A,(IX+9)
	LD	IY,(IX+27)
	LD	(IY+0),BC
	LD	(IY+3),A
;  147	            contact_point->y = a.y;
.LINE 147

	LD	BC,(IX+37)
	LD	A,(IX+40)
	LD	(IY+4),BC
	LD	(IY+7),A
;  148	            return TRUE;
.LINE 148

	LD	A,1
	JR	L_90
;  149	        }
;  150	    } else if (ortho == VERTICAL && abs(ac_x) <= BALL_RAYON) {
L_88:
.LINE 150

	LD	A,(IX+30)
	CP	A,2
	JR	NZ,L_89
	LD	BC,(IX+-12)
	LD	A,(IX+-9)
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	LD	HL,3
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_89
;  151	        t = ac_y / (b.y - a.y);
.LINE 151

	LD	HL,(IX+37)
	LD	E,(IX+40)
	LD	BC,(IX+46)
	LD	A,(IX+49)
	CALL	__fsub
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-8)
	LD	A,(IX+-5)
	CALL	__fdiv
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  152	
;  153	        if (t >= 0 && t <= 1) {
.LINE 153

	LD	HL,BC
	LD	E,(IX+-1)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_89
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fcmp
	JP	M,L_89
;  154	            contact_point->x = a.x;
.LINE 154

	LD	BC,(IX+33)
	LD	A,(IX+36)
	LD	IY,(IX+27)
	LD	(IY+0),BC
	LD	(IY+3),A
;  155	            contact_point->y = ball.pos.y;
.LINE 155

	LD	BC,(IX+10)
	LD	A,(IX+13)
	LD	(IY+4),BC
	LD	(IY+7),A
;  156	            return TRUE;
.LINE 156

	LD	A,1
	JR	L_90
;  157	        }
;  158	    }
L_89:
.LINE 158

;  159	    return FALSE;
.LINE 159

	XOR	A,A
;  160	}
L_90:
.LINE 160

	LD	SP,IX
	POP	IX
	RET	


;**************************** _calculateContactOrtho ***************************
;Name                         Addr/Register   Size   Type
;_abs                                IMPORT  -----   function
;ac_x                                 IX-12      4   variable
;ac_y                                  IX-8      4   variable
;t                                     IX-4      4   variable
;b                                    IX+42      8   parameter
;a                                    IX+33      8   parameter
;ortho                                IX+30      1   parameter
;contact_point                        IX+27      3   parameter
;ball                                  IX+6     20   parameter


; Stack Frame Size: 63 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "calculateContactOrtho",160,"_calculateContactOrtho"
;  161	
;  162	uint8_t checkOrthoDistance(t_ball ball, t_precision_pos a, t_precision_pos b, uint8_t ortho) {
_checkOrthoDistance:
.DEFINE "_checkOrthoDistance"

.VALUE _checkOrthoDistance

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "checkOrthoDistance",162,"_checkOrthoDistance"

.LINE 162

.DEFINE "ball"

.CLASS 65

.VALUE 6

.TAG "s_ball"

.TYPE 8

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE 27

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 36

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "ortho"

.CLASS 65

.VALUE 45

.TYPE 12

.ENDEF

.DEFINE "ac"

.CLASS 65

.VALUE -4

.TYPE 6

.ENDEF

.DEFINE "bc"

.CLASS 65

.VALUE -8

.TYPE 6

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
;  163	    double ac, bc;
;  164	
;  165	    switch (ortho) {
.LINE 165

	LD	A,(IX+45)
	UEXT	HL
	LD	L,A
	CALL	__seqcaseD
	JP	(HL)
L__58:
	DW	3
	DW	0
	DB	0
	DW24	L_91	

	DW24	L_92	

	DW24	L_93	

	DW24	L_96	

;  166	        case FALSE:
L_91:
.LINE 166

;  167	            return FALSE;
.LINE 167

	XOR	A,A
	JR	L_98
;  168	        case HORIZONTAL:
L_92:
.LINE 168

;  169	            ac = abs(ball.pos.x - a.x);
.LINE 169

	LD	HL,(IX+27)
	LD	E,(IX+30)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  170	            bc = abs(ball.pos.x - b.x);
.LINE 170

	LD	HL,(IX+36)
	LD	E,(IX+39)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-8),BC
	LD	(IX+-5),A
;  171	            break;
.LINE 171

	JR	L_96
;  172	        case VERTICAL:
L_93:
.LINE 172

;  173	            ac = abs(ball.pos.y - a.y);
.LINE 173

	LD	HL,(IX+31)
	LD	E,(IX+34)
	LD	BC,(IX+10)
	LD	A,(IX+13)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  174	            bc = abs(ball.pos.y - b.y);
.LINE 174

	LD	HL,(IX+40)
	LD	E,(IX+43)
	LD	BC,(IX+10)
	LD	A,(IX+13)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-8),BC
	LD	(IX+-5),A
;  175	            break;
;  176	    }
L_96:
.LINE 176

;  177	    if (ac > BALL_RAYON && bc > BALL_RAYON) { return TRUE; }
.LINE 177

	LD	HL,4194304
	LD	E,64
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fcmp
	JP	P,L_97
	LD	BC,(IX+-8)
	LD	A,(IX+-5)
	CALL	__fcmp
	JP	P,L_97
	LD	A,1
	JR	L_98
L_97:
;  178	    return FALSE;
.LINE 178

	XOR	A,A
;  179	}
L_98:
.LINE 179

	LD	SP,IX
	POP	IX
	RET	


;**************************** _checkOrthoDistance ***************************
;Name                         Addr/Register   Size   Type
;_abs                                IMPORT  -----   function
;bc                                    IX-8      4   variable
;ac                                    IX-4      4   variable
;ortho                                IX+45      1   parameter
;b                                    IX+36      8   parameter
;a                                    IX+27      8   parameter
;ball                                  IX+6     20   parameter


; Stack Frame Size: 56 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "checkOrthoDistance",179,"_checkOrthoDistance"
;  180	
;  181	void addContact(uint8_t *contact, uint8_t n) {
_addContact:
.DEFINE "_addContact"

.VALUE _addContact

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "addContact",181,"_addContact"

.LINE 181

.DEFINE "contact"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  182	    uint8_t i;
;  183	
;  184	    i = 0;
.LINE 184

	LD	(IX+-1),0
;  185	
;  186	    while (contact[i]) { ++i; }
.LINE 186

	JR	L_99
L_100:
	INC	(IX+-1)
L_99:
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+6)
	ADD	HL,BC
	LD	(IX+-4),HL
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_100
;  187	    contact[i] = n;
.LINE 187

	LD	HL,(IX+-4)
	LD	A,(IX+9)
	LD	(HL),A
;  188	}
.LINE 188

	LD	SP,IX
	POP	IX
	RET	


;**************************** _addContact ***************************
;Name                         Addr/Register   Size   Type
;G_23                                  IX-4      3   variable
;i                                     IX-1      1   variable
;n                                     IX+9      1   parameter
;contact                               IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "addContact",188,"_addContact"
;  189	
;  190	void setAB(t_obstacle *obstacle, t_precision_pos *a, t_precision_pos *b, uint8_t *j_a, uint8_t *j_b, uint8_t j, uint8_t direction) {
_setAB:
.DEFINE "_setAB"

.VALUE _setAB

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "setAB",190,"_setAB"

.LINE 190

.DEFINE "obstacle"

.CLASS 65

.VALUE 6

.TAG "s_obstacle"

.TYPE 40

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE 9

.TAG "s_precision_pos"

.TYPE 40

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 12

.TAG "s_precision_pos"

.TYPE 40

.ENDEF

.DEFINE "j_a"

.CLASS 65

.VALUE 15

.TYPE 44

.ENDEF

.DEFINE "j_b"

.CLASS 65

.VALUE 18

.TYPE 44

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE 21

.TYPE 12

.ENDEF

.DEFINE "direction"

.CLASS 65

.VALUE 24

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  191	    *j_a = direction + j;
.LINE 191

	LD	HL,(IX+15)
	LD	A,(IX+24)
	ADD	A,(IX+21)
	LD	(HL),A
;  192	    *j_a %= NUMBER_POINT_OBSTACLE;
.LINE 192

	LD	HL,(IX+15)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,4
	CALL	__irems
	LD	IY,(IX+15)
	LD	(IY),L
;  193	    *j_b = (*j_a) + 1;
.LINE 193

	LD	HL,(IX+18)
	LD	A,(IY)
	INC	A
	LD	(HL),A
;  194	    *j_b %= NUMBER_POINT_OBSTACLE;
.LINE 194

	LD	HL,(IX+18)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,4
	CALL	__irems
	LD	IY,(IX+18)
	LD	(IY),L
;  195	
;  196	    a->x = (double)obstacle->point[*j_a].x;
.LINE 196

	LD	HL,(IX+15)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LEA	BC,IY+0
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+0)
	XOR	A,A
	CALL	__ultof
	LD	IY,(IX+9)
	LD	(IY+0),BC
	LD	(IY+3),A
;  197	    a->y = (double)obstacle->point[*j_a].y;
.LINE 197

	LD	HL,(IX+15)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LEA	BC,IY+0
	ADD	HL,BC
	LD	IY,HL
	UEXT	HL
	LD	L,(IY+3)
	LD	A,H
	LD	BC,HL
	CALL	__ultof
	LD	IY,(IX+9)
	LD	(IY+4),BC
	LD	(IY+7),A
;  198	    b->x = (double)obstacle->point[*j_b].x;
.LINE 198

	LD	HL,(IX+18)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LEA	BC,IY+0
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+0)
	XOR	A,A
	CALL	__ultof
	LD	IY,(IX+12)
	LD	(IY+0),BC
	LD	(IY+3),A
;  199	    b->y = (double)obstacle->point[*j_b].y;
.LINE 199

	LD	HL,(IX+18)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	IY,(IX+6)
	LEA	BC,IY+0
	ADD	HL,BC
	LD	IY,HL
	UEXT	HL
	LD	L,(IY+3)
	LD	A,H
	LD	BC,HL
	CALL	__ultof
	LD	IY,(IX+12)
	LD	(IY+4),BC
	LD	(IY+7),A
;  200	}
.LINE 200

	LD	SP,IX
	POP	IX
	RET	


;**************************** _setAB ***************************
;Name                         Addr/Register   Size   Type
;direction                            IX+24      1   parameter
;j                                    IX+21      1   parameter
;j_b                                  IX+18      3   parameter
;j_a                                  IX+15      3   parameter
;b                                    IX+12      3   parameter
;a                                     IX+9      3   parameter
;obstacle                              IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "setAB",200,"_setAB"
;  201	
;  202	uint8_t getContactPoint(uint8_t matrix[MATRIX_X_LENGTH][MATRIX_Y_LENGTH], t_obstacle *obstacles, t_ball ball, t_precision_pos *contact_point) {
_getContactPoint:
.DEFINE "_getContactPoint"

.VALUE _getContactPoint

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getContactPoint",202,"_getContactPoint"

.LINE 202

.DEFINE "matrix"

.CLASS 65

.VALUE 6

.DIM 5

.TYPE 812

.ENDEF

.DEFINE "obstacles"

.CLASS 65

.VALUE 9

.TAG "s_obstacle"

.TYPE 40

.ENDEF

.DEFINE "ball"

.CLASS 65

.VALUE 12

.TAG "s_ball"

.TYPE 8

.ENDEF

.DEFINE "contact_point"

.CLASS 65

.VALUE 33

.TAG "s_precision_pos"

.TYPE 40

.ENDEF

.DEFINE "j_a"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "obstacle"

.CLASS 65

.VALUE -5

.TAG "s_obstacle"

.TYPE 40

.ENDEF

.DEFINE "a"

.CLASS 65

.VALUE -13

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -14

.TYPE 12

.ENDEF

.DEFINE "ball_direction"

.CLASS 65

.VALUE -15

.TYPE 12

.ENDEF

.DEFINE "contact"

.CLASS 65

.VALUE -19

.DIM 4

.TYPE 108

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -27

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "j_b"

.CLASS 65

.VALUE -28

.TYPE 12

.ENDEF

.DEFINE "nb_obstacle"

.CLASS 65

.VALUE -29

.TYPE 12

.ENDEF

.DEFINE "contact_points"

.CLASS 65

.VALUE -61

.DIM 4

.TAG "s_precision_pos"

.TYPE 104

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-70
	LD	SP,HL
;  203	    uint8_t i, j, j_a, j_b, nb_obstacle, ball_direction;
;  204	    t_precision_pos a, b;
;  205	    uint8_t contact[NUMBER_POINT_OBSTACLE];
;  206	    t_precision_pos contact_points[NUMBER_POINT_OBSTACLE];
;  207	    t_obstacle *obstacle;
;  208	
;  209	    obstacle = obstacles;
.LINE 209

	LD	BC,(IX+9)
	LD	(IX+-5),BC
;  210	
;  211	    nb_obstacle = nbObstacle(obstacles);
.LINE 211

	LD	BC,(IX+9)
	PUSH	BC
	CALL	_nbObstacle
	POP	BC
	LD	(IX+-29),A
;  212	    ball_direction = ballDirection(ball);
.LINE 212

	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-21
	LD	SP,IY
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+12
	LD	BC,20
	LDIR	
	CALL	_ballDirection
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-15),A
;  213	    resetContact(contact);
.LINE 213

	PEA	IX+-19
	CALL	_resetContact
	POP	BC
;  214	
;  215	    for (i = 0; i < nb_obstacle; ++i) {
.LINE 215

	LD	(IX+-14),0
	JR	L_127
L_125:
;  216	        for (j = 0; j < NUMBER_SIDE_TO_CHECK; ++j) {
.LINE 216

	LD	(IX+-2),0
	JR	L_113
L_111:
;  217	            setAB(obstacle, &a, &b, &j_a, &j_b, j, ball_direction);
.LINE 217

	LD	C,(IX+-15)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	PEA	IX+-28
	PEA	IX+-1
	PEA	IX+-27
	PEA	IX+-13
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_setAB
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  218	
;  219	            if (!preCheck(ball, ball_direction, a, b, obstacle->hide[j_a])) { continue; }
.LINE 219

	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-5)
	LEA	HL,IY+23
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-27
	LD	BC,8
	LDIR	
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-13
	LD	BC,8
	LDIR	
	LD	C,(IX+-15)
	LD	B,0
	PUSH	BC
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-21
	LD	SP,IY
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+12
	LD	BC,20
	LDIR	
	CALL	_preCheck
	LD	IY,45
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_112
;  220	
;  221	            if (checkOrthoDistance(ball, a, b, obstacle->ortho[j_a])) {
.LINE 221

	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-5)
	LEA	HL,IY+16
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-27
	LD	BC,8
	LDIR	
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-13
	LD	BC,8
	LDIR	
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-21
	LD	SP,IY
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+12
	LD	BC,20
	LDIR	
	LD	(IX+-70),BC
	CALL	_checkOrthoDistance
	LD	BC,(IX+-70)
	LD	IY,42
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_110
;  222	                if (calculateContactOrtho(ball, &contact_points[j_a], obstacle->ortho[j_a], a, b)) {
.LINE 222

	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-27
	LD	BC,8
	LDIR	
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-13
	LD	BC,8
	LDIR	
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	IY,(IX+-5)
	LEA	HL,IY+16
	ADD	HL,BC
	LD	C,(HL)
	LD	B,0
	PUSH	BC
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IX+-61
	ADD	HL,BC
	PUSH	HL
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-21
	LD	SP,IY
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+12
	LD	BC,20
	LDIR	
	CALL	_calculateContactOrtho
	LD	IY,45
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_112
;  223	                    addContact(contact, j_a + 1);
.LINE 223

	LD	C,(IX+-1)
	INC	C
	LD	B,0
	PUSH	BC
	PEA	IX+-19
	CALL	_addContact
	POP	BC
	POP	BC
;  224	                }
.LINE 224

;  225	                continue;
.LINE 225

	JR	L_112
;  226	            }
L_110:
.LINE 226

;  227	
;  228	            if (calculateContact(&contact_points[j_a], a, b.x - a.x, a.x - ball.pos.x, b.y - a.y, a.y - ball.pos.y)) {
.LINE 228

	LEA	BC,IX+12
	LD	(IX+-64),BC
	LD	IY,(IX+-64)
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+-9)
	LD	A,(IX+-6)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	HL,(IX+-9)
	LD	E,(IX+-6)
	LD	BC,(IX+-23)
	LD	A,(IX+-20)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	HL,(IY+0)
	LD	E,(IY+3)
	LD	BC,(IX+-13)
	LD	A,(IX+-10)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	HL,(IX+-13)
	LD	E,(IX+-10)
	LD	BC,(IX+-27)
	LD	A,(IX+-24)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-13
	LD	BC,8
	LDIR	
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IX+-61
	ADD	HL,BC
	PUSH	HL
	CALL	_calculateContact
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_112
;  229	                addContact(contact, j_a + 1);
.LINE 229

	LD	C,(IX+-1)
	INC	C
	LD	B,0
	PUSH	BC
	PEA	IX+-19
	CALL	_addContact
	POP	BC
	POP	BC
;  230	            }
;  231	        }
L_112:
.LINE 231

	INC	(IX+-2)
L_113:
	LD	A,(IX+-2)
	CP	A,2
	JR	C,L_111
;  232	        if (contact[0]) {
.LINE 232

	LD	A,(IX+-19)
	OR	A,A
	JR	Z,L_124
;  233	            for (j = NUMBER_SIDE_TO_CHECK; j < NUMBER_POINT_OBSTACLE; ++j) {
.LINE 233

	LD	(IX+-2),2
	JR	L_117
L_115:
;  234	                setAB(obstacle, &a, &b, &j_a, &j_b, j, ball_direction);
.LINE 234

	LD	C,(IX+-15)
	LD	B,0
	PUSH	BC
	LD	C,(IX+-2)
	PUSH	BC
	PEA	IX+-28
	PEA	IX+-1
	PEA	IX+-27
	PEA	IX+-13
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_setAB
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  235	
;  236	                if (calculateContact(&contact_points[j_a], a, b.x - a.x, a.x - ball.pos.x, b.y - a.y, a.y - ball.pos.y)) {
.LINE 236

	LEA	BC,IX+12
	LD	(IX+-67),BC
	LD	IY,(IX+-67)
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+-9)
	LD	A,(IX+-6)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	HL,(IX+-9)
	LD	E,(IX+-6)
	LD	BC,(IX+-23)
	LD	A,(IX+-20)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	HL,(IY+0)
	LD	E,(IY+3)
	LD	BC,(IX+-13)
	LD	A,(IX+-10)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	HL,(IX+-13)
	LD	E,(IX+-10)
	LD	BC,(IX+-27)
	LD	A,(IX+-24)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-13
	LD	BC,8
	LDIR	
	LD	A,(IX+-1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LEA	HL,IX+-61
	ADD	HL,BC
	PUSH	HL
	CALL	_calculateContact
	LD	IY,36
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_116
;  237	                    addContact(contact, j_a + 1);
.LINE 237

	LD	C,(IX+-1)
	INC	C
	LD	B,0
	PUSH	BC
	PEA	IX+-19
	CALL	_addContact
	POP	BC
	POP	BC
;  238	                }
;  239	            }
L_116:
.LINE 239

	INC	(IX+-2)
L_117:
	LD	A,(IX+-2)
	CP	A,4
	JR	C,L_115
;  240	            setContactPoint(contact_points, contact_point, contact);
.LINE 240

	PEA	IX+-19
	LD	BC,(IX+33)
	PUSH	BC
	PEA	IX+-61
	CALL	_setContactPoint
	POP	BC
	POP	BC
	POP	BC
;  241	            if (!hurtObstacle(matrix, obstacles, obstacle) && obstacle->life) { printObstacle(obstacle); }
.LINE 241

	LD	BC,(IX+-5)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_hurtObstacle
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_121
	LD	IY,(IX+-5)
	LD	HL,(IY+21)
	CALL	__scmpzero
	JR	Z,L_121
	LD	BC,(IX+-5)
	PUSH	BC
	CALL	_printObstacle
	POP	BC
L_121:
;  242	            return TRUE;
.LINE 242

	LD	A,1
	JR	L_129
;  243	        }
L_124:
.LINE 243

;  244	        obstacle = obstacle->next;
.LINE 244

	LD	IY,(IX+-5)
	LD	BC,(IY+32)
	LD	(IX+-5),BC
	INC	(IX+-14)
;  245	    }
L_127:
.LINE 245

	LD	A,(IX+-14)
	CP	A,(IX+-29)
	JR	C,L_125
;  246	    return FALSE;
.LINE 246

	XOR	A,A
;  247	}
L_129:
.LINE 247

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getContactPoint ***************************
;Name                         Addr/Register   Size   Type
;_printObstacle                      IMPORT  -----   function
;_nbObstacle                         IMPORT  -----   function
;contact_points                       IX-61     32   variable
;nb_obstacle                          IX-29      1   variable
;j_b                                  IX-28      1   variable
;b                                    IX-27      8   variable
;contact                              IX-19      4   variable
;ball_direction                       IX-15      1   variable
;i                                    IX-14      1   variable
;a                                    IX-13      8   variable
;obstacle                              IX-5      3   variable
;j                                     IX-2      1   variable
;j_a                                   IX-1      1   variable
;contact_point                        IX+33      3   parameter
;ball                                 IX+12     20   parameter
;obstacles                             IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 106 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getContactPoint",247,"_getContactPoint"
;  248	
;  249	void turnBall(t_ball *ball, t_precision_pos contact_point) {
_turnBall:
.DEFINE "_turnBall"

.VALUE _turnBall

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "turnBall",249,"_turnBall"

.LINE 249

.DEFINE "ball"

.CLASS 65

.VALUE 6

.TAG "s_ball"

.TYPE 40

.ENDEF

.DEFINE "contact_point"

.CLASS 65

.VALUE 9

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
;  250	    if (ball->pos.x == contact_point.x) {
.LINE 250

	LD	IY,(IX+6)
	LD	HL,(IY+0)
	LD	E,(IY+3)
	LD	BC,(IX+9)
	LD	A,(IX+12)
	CALL	__fcmp
	JR	NZ,L_131
;  251	        ball->direction = primaryMeasure(-(ball->direction));
.LINE 251

	LD	IY,(IX+6)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fneg
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_primaryMeasure
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY+12),HL
	LD	(IY+15),E
;  252	    } else {
.LINE 252

	JR	L_132
L_131:
;  253	        ball->direction = primaryMeasure(2*(atan((contact_point.y - ball->pos.y) / (ball->pos.x - contact_point.x))) + M_PI - ball->direction);
.LINE 253

	LD	IY,(IX+6)
	LEA	BC,IY+0
	LD	(IX+-3),BC
	LD	IY,(IX+-3)
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	BC,(IX+13)
	LD	A,(IX+16)
	CALL	__fsub
	LD	(IX+-6),BC
	LD	(IX+-7),A
	LD	HL,(IX+9)
	LD	E,(IX+12)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-7)
	LD	BC,(IX+-6)
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_atan
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fmul
	LD	HL,4788187
	LD	E,64
	CALL	__fadd
	LD	IY,(IX+6)
	LD	HL,(IY+12)
	LD	E,(IY+15)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_primaryMeasure
	POP	BC
	POP	BC
	LD	IY,(IX+6)
	LD	(IY+12),HL
	LD	(IY+15),E
;  254	    }
L_132:
.LINE 254

;  255	    dbg_sprintf(dbgout, " ball direction : %d\n", deg(ball->direction));
.LINE 255

	LD	IY,(IX+6)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_deg
	POP	BC
	POP	BC
	LD	BC,HL
	CALL	__stoi
	PUSH	HL
	LD	BC,L__78
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
;  256	}
.LINE 256

	LD	SP,IX
	POP	IX
	RET	


;**************************** _turnBall ***************************
;Name                         Addr/Register   Size   Type
;_deg                                IMPORT  -----   function
;_sprintf                            IMPORT  -----   function
;_atan                               IMPORT  -----   function
;contact_point                         IX+9      8   parameter
;ball                                  IX+6      3   parameter


; Stack Frame Size: 25 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "turnBall",256,"_turnBall"
	SEGMENT STRSECT
L__78:
	DB	" ball direction : %d"
	DB	10,0
	SEGMENT CODE
;  257	
;  258	void initSpeed(double *speed, double *speed_total, uint32_t *nb_speed) {
_initSpeed:
.DEFINE "_initSpeed"

.VALUE _initSpeed

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initSpeed",258,"_initSpeed"

.LINE 258

.DEFINE "speed"

.CLASS 65

.VALUE 6

.TYPE 38

.ENDEF

.DEFINE "speed_total"

.CLASS 65

.VALUE 9

.TYPE 38

.ENDEF

.DEFINE "nb_speed"

.CLASS 65

.VALUE 12

.TYPE 47

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  259	    *speed = SPEED*timer_1_Counter;
.LINE 259

	LD	BC,(15859712)
	LD	A,(15859715)
	CALL	__ultof
	LD	HL,2097152
	LD	E,59
	CALL	__fmul
	LD	IY,(IX+6)
	LD	(IY),BC
	LD	(IY+3),A
;  260	    (*nb_speed)++;
.LINE 260

	LD	IY,(IX+12)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	A,1
	CALL	__ladd_b
	LD	(IY),HL
	LD	(IY+3),E
;  261	    *speed_total += *speed;
.LINE 261

	LD	IY,(IX+6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+9)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  262	    dbg_sprintf(dbgout, "          speed : %d.%d\n", (int)*speed, (int)(*speed*1000000 - (int)*speed*1000000));
.LINE 262

	LD	IY,(IX+6)
	LD	HL,7611392
	LD	E,73
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	(IX+-3),BC
	LD	(IX+-4),A
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__ftol
	LD	HL,BC
	LD	BC,1000000
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	A,(IX+-4)
	LD	BC,(IX+-3)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__ftol
	PUSH	BC
	LD	BC,L__80
	PUSH	BC
	LD	BC,16449536
	PUSH	BC
	CALL	_sprintf
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  263	    //dbg_sprintf(dbgout, "timer_1_Counter : %d\n", timer_1_Counter);
;  264	    timer_1_Counter = 0;
.LINE 264

	LD	BC,0
	XOR	A,A
	LD	(15859712),BC
	LD	(15859715),A
;  265	}
.LINE 265

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initSpeed ***************************
;Name                         Addr/Register   Size   Type
;_sprintf                            IMPORT  -----   function
;nb_speed                             IX+12      3   parameter
;speed_total                           IX+9      3   parameter
;speed                                 IX+6      3   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initSpeed",265,"_initSpeed"
	SEGMENT STRSECT
L__80:
	DB	"          speed : %d.%d"
	DB	10,0
	SEGMENT CODE
;  266	
;  267	void ballMove(uint8_t matrix[MATRIX_X_LENGTH][MATRIX_Y_LENGTH], t_obstacle *obstacles, t_ball *ball, double *speed_total, uint32_t *nb_speed) {
_ballMove:
.DEFINE "_ballMove"

.VALUE _ballMove

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "ballMove",267,"_ballMove"

.LINE 267

.DEFINE "matrix"

.CLASS 65

.VALUE 6

.DIM 5

.TYPE 812

.ENDEF

.DEFINE "obstacles"

.CLASS 65

.VALUE 9

.TAG "s_obstacle"

.TYPE 40

.ENDEF

.DEFINE "ball"

.CLASS 65

.VALUE 12

.TAG "s_ball"

.TYPE 40

.ENDEF

.DEFINE "speed_total"

.CLASS 65

.VALUE 15

.TYPE 38

.ENDEF

.DEFINE "nb_speed"

.CLASS 65

.VALUE 18

.TYPE 47

.ENDEF

.DEFINE "speed"

.CLASS 65

.VALUE -4

.TYPE 6

.ENDEF

.DEFINE "contact_point"

.CLASS 65

.VALUE -12

.TAG "s_precision_pos"

.TYPE 8

.ENDEF

.DEFINE "checking_ball"

.CLASS 65

.VALUE -32

.TAG "s_ball"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+-41
	LD	SP,HL
;  268	    double speed;
;  269	    t_ball checking_ball;
;  270	    t_precision_pos contact_point;
;  271	
;  272	    checking_ball = *ball;
.LINE 272

	LEA	DE,IX+-32
	LD	HL,(IX+12)
	LD	BC,20
	LDIR	
;  273	    initSpeed(&speed, speed_total, nb_speed);
.LINE 273

	LD	BC,(IX+18)
	PUSH	BC
	LD	BC,(IX+15)
	PUSH	BC
	PEA	IX+-4
	CALL	_initSpeed
	POP	BC
	POP	BC
	POP	BC
;  274	
;  275	    checking_ball.pos.x += cos(checking_ball.direction)*speed;
.LINE 275

	LEA	BC,IX+-32
	LD	(IX+-35),BC
	LD	C,(IX+-17)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-20)
	PUSH	BC
	CALL	_cos
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fmul
	LD	IY,(IX+-35)
	LD	HL,(IY+0)
	LD	E,(IY+3)
	CALL	__fadd
	LD	(IY+0),BC
	LD	(IY+3),A
;  276	    checking_ball.pos.y -= sin(checking_ball.direction)*speed;
.LINE 276

	LD	C,(IX+-17)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-20)
	PUSH	BC
	LD	(IX+-41),IY
	CALL	_sin
	LD	IY,(IX+-41)
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fsub
	LD	IY,(IX+-35)
	LD	(IY+4),BC
	LD	(IY+7),A
;  277	
;  278	    if (getContactPoint(matrix, obstacles, checking_ball, &contact_point)) {
.LINE 278

	PEA	IX+-12
	LD	IY,0
	ADD	IY,SP
	LEA	IY,IY+-21
	LD	SP,IY
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-32
	LD	BC,20
	LDIR	
	LD	DE,(IX+9)
	PUSH	DE
	LD	DE,(IX+6)
	PUSH	DE
	LD	(IX+-41),BC
	CALL	_getContactPoint
	LD	BC,(IX+-41)
	LD	IY,30
	ADD	IY,SP
	LD	SP,IY
	OR	A,A
	JR	Z,L_137
;  279	        turnBall(&checking_ball, contact_point);
.LINE 279

	PUSH	BC
	PUSH	BC
	PUSH	BC
	OR	A,A
	SBC	HL,HL
	ADD	HL,SP
	LD	DE,HL
	LEA	HL,IX+-12
	LD	BC,8
	LDIR	
	PEA	IX+-32
	CALL	_turnBall
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  280	    }
L_137:
.LINE 280

;  281	    checking_ball.old_pos.x = (uint24_t)ball->pos.x;
.LINE 281

	LEA	BC,IX+-24
	LD	(IX+-38),BC
	LD	IY,(IX+12)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__ftol
	LD	IY,(IX+-38)
	LD	(IY+0),BC
;  282	    checking_ball.old_pos.y = (uint8_t)ball->pos.y;
.LINE 282

	LD	IY,(IX+12)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__ftol
	LD	IY,(IX+-38)
	LD	(IY+3),C
;  283	    *ball = checking_ball;
.LINE 283

	LD	DE,(IX+12)
	LEA	HL,IX+-32
	LD	BC,20
	LDIR	
.LINE 284

	LD	SP,IX
	POP	IX
	RET	


;**************************** _ballMove ***************************
;Name                         Addr/Register   Size   Type
;_sin                                IMPORT  -----   function
;_cos                                IMPORT  -----   function
;checking_ball                        IX-32     20   variable
;contact_point                        IX-12      8   variable
;speed                                 IX-4      4   variable
;nb_speed                             IX+18      3   parameter
;speed_total                          IX+15      3   parameter
;ball                                 IX+12      3   parameter
;obstacles                             IX+9      3   parameter
;matrix                                IX+6      3   parameter


; Stack Frame Size: 62 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "ballMove",284,"_ballMove"
	XREF _setAdjHiddenObstacle:ROM
	XREF _eraseObstacle:ROM
	XREF _printObstacle:ROM
	XREF _nbObstacle:ROM
	XREF _removeObstacle:ROM
	XREF _DIRECTION:ROM
	XREF _sprintf:ROM
	XREF _abs:ROM
	XREF _sqrt:ROM
	XREF _sin:ROM
	XREF _cos:ROM
	XREF _atan:ROM
	XREF __imuls:ROM
	XREF __irems:ROM
	XREF __fadd:ROM
	XREF __fsub:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fneg:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ltof:ROM
	XREF __ultof:ROM
	XREF __stoi:ROM
	XREF __itol:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __seqcaseD:ROM
	XREF __imul_b:ROM
	XREF __ladd_b:ROM
	XDEF _ballMove
	XDEF _initSpeed
	XDEF _turnBall
	XDEF _getContactPoint
	XDEF _setAB
	XDEF _addContact
	XDEF _checkOrthoDistance
	XDEF _calculateContactOrtho
	XDEF _preCheck
	XDEF _checkDirection
	XDEF _hurtObstacle
	XDEF _ballDirection
	XDEF _resetContact
	XDEF _setContactPoint
	XDEF _calculateContact
	XDEF _primaryMeasure
	XDEF _deg
	XDEF _rad
	END
